{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "공통 인터페이스 및 추상화 계층 설계",
        "description": "다양한 공공데이터 API를 통합하기 위한 공통 인터페이스와 추상화 계층을 설계하고 구현",
        "details": "BaseAPIClient, BaseRepository, BaseService 등의 추상 클래스를 정의하고, 공통 데이터 모델과 인터페이스를 설계. Strategy Pattern과 Template Method Pattern을 활용하여 확장 가능한 구조 구축. typing 모듈을 활용한 Protocol 정의와 Generic 타입 활용.",
        "testStrategy": "추상 클래스의 구현체를 통한 단위 테스트, 인터페이스 계약 검증, 타입 힌트 검증",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 추상 클래스와 Protocol 정의",
            "description": "BaseAPIClient, BaseRepository, BaseService 등의 핵심 추상 클래스와 typing.Protocol을 활용한 인터페이스 정의",
            "dependencies": [],
            "details": "abc 모듈과 typing.Protocol을 활용하여 BaseAPIClient(HTTP 통신 담당), BaseRepository(데이터 접근 담당), BaseService(비즈니스 로직 담당) 추상 클래스 정의. Generic 타입과 TypeVar를 활용한 타입 안전성 확보. 각 클래스의 필수 메서드와 선택적 메서드 구분하여 정의.",
            "status": "done",
            "testStrategy": "추상 클래스 인스턴스화 방지 테스트, Protocol 준수 검증 테스트, 타입 힌트 검증"
          },
          {
            "id": 2,
            "title": "공통 데이터 모델 및 응답 형식 표준화",
            "description": "API 응답과 내부 데이터 교환을 위한 공통 데이터 모델과 표준 응답 형식 정의",
            "dependencies": [],
            "details": "Pydantic BaseModel을 활용한 공통 응답 모델(APIResponse, ErrorResponse, PaginationResponse) 정의. 데이터 검증, 직렬화/역직렬화 로직 포함. 성공/실패 응답의 일관된 구조 설계. 날짜, 시간, 페이지네이션 등 공통 필드 표준화.",
            "status": "done",
            "testStrategy": "데이터 모델 검증 테스트, 직렬화/역직렬화 테스트, 필드 유효성 검사 테스트"
          },
          {
            "id": 3,
            "title": "Strategy Pattern 기반 API 클라이언트 전략 구현",
            "description": "다양한 API 인증 방식과 요청 처리 방식을 Strategy Pattern으로 구현",
            "dependencies": [
              "1.1"
            ],
            "details": "AuthenticationStrategy(API Key, OAuth, Bearer Token 등), RequestStrategy(GET, POST, 배치 요청 등), ErrorHandlingStrategy(재시도, 백오프, 로깅 등) 구현. 각 전략을 독립적으로 교체 가능하도록 설계. 설정 파일을 통한 전략 선택 지원.",
            "status": "done",
            "testStrategy": "각 전략 개별 테스트, 전략 교체 테스트, 설정 기반 전략 선택 테스트"
          },
          {
            "id": 4,
            "title": "Template Method Pattern 기반 API 처리 템플릿 구현",
            "description": "API 요청-응답 처리의 공통 흐름을 Template Method Pattern으로 구현",
            "dependencies": [
              "1.1",
              "1.2",
              "1.3"
            ],
            "details": "요청 전처리 → 인증 → API 호출 → 응답 검증 → 후처리의 템플릿 메서드 구현. 각 단계에서 hook 메서드를 제공하여 하위 클래스에서 커스터마이징 가능. 비동기 처리 지원, 에러 처리 및 로깅을 템플릿에 포함.",
            "status": "done",
            "testStrategy": "템플릿 메서드 실행 순서 테스트, hook 메서드 커스터마이징 테스트, 비동기 처리 테스트"
          },
          {
            "id": 5,
            "title": "확장 가능한 플러그인 시스템 및 레지스트리 구현",
            "description": "새로운 API 클라이언트를 쉽게 추가할 수 있는 플러그인 시스템과 서비스 레지스트리 구현",
            "dependencies": [
              "1.1",
              "1.2",
              "1.3",
              "1.4"
            ],
            "details": "APIClientRegistry를 통한 클라이언트 등록 및 관리, 동적 클라이언트 로딩 지원. 플러그인 디스커버리 메커니즘, 설정 기반 클라이언트 활성화/비활성화. Factory Pattern을 활용한 클라이언트 인스턴스 생성. 네임스페이스 기반 클라이언트 관리.",
            "status": "done",
            "testStrategy": "플러그인 등록/해제 테스트, 동적 로딩 테스트, Factory 패턴 테스트, 네임스페이스 격리 테스트"
          }
        ]
      },
      {
        "id": 2,
        "title": "K-Startup API 클라이언트 리팩토링",
        "description": "기존 K-Startup API 클라이언트를 새로운 추상화 계층에 맞게 리팩토링하고 안정성 개선",
        "details": "현재 K-Startup API 클라이언트를 BaseAPIClient를 상속받도록 리팩토링. 에러 처리, 재시도 로직, 응답 검증 강화. httpx 또는 aiohttp를 활용한 비동기 HTTP 클라이언트 구현. API 응답 데이터 표준화 및 검증 로직 추가.",
        "testStrategy": "Mock을 활용한 API 클라이언트 테스트, 에러 시나리오 테스트, 응답 데이터 검증 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "BaseAPIClient 추상 클래스 상속 및 K-Startup 클라이언트 기본 구조 리팩토링",
            "description": "기존 K-Startup API 클라이언트를 BaseAPIClient를 상속받는 구조로 변경하고 기본 메서드들을 재정의",
            "dependencies": [],
            "details": "app/services/apis/kstartup.py 파일에서 KStartupAPIClient 클래스가 BaseAPIClient를 상속받도록 수정. _make_request, _handle_response 등의 추상 메서드 구현. 기존 API 엔드포인트 URL 및 인증 정보 설정 유지.",
            "status": "done",
            "testStrategy": "BaseAPIClient 상속 확인, 추상 메서드 구현 검증, 기본 API 호출 테스트"
          },
          {
            "id": 2,
            "title": "비동기 HTTP 클라이언트 구현 및 연결 관리 개선",
            "description": "httpx 또는 aiohttp를 활용한 비동기 HTTP 클라이언트로 교체하고 연결 풀 관리 최적화",
            "dependencies": [
              "2.1"
            ],
            "details": "httpx.AsyncClient를 사용하여 비동기 HTTP 요청 구현. 연결 풀 설정, 타임아웃 관리, 세션 관리 개선. async/await 패턴으로 모든 API 메서드 변경. 컨텍스트 매니저를 활용한 리소스 관리.",
            "status": "done",
            "testStrategy": "비동기 API 호출 테스트, 연결 풀 설정 검증, 타임아웃 시나리오 테스트"
          },
          {
            "id": 3,
            "title": "강화된 에러 처리 및 재시도 로직 구현",
            "description": "API 호출 실패 시 재시도 메커니즘과 포괄적인 에러 처리 로직 구현",
            "dependencies": [
              "2.2"
            ],
            "details": "tenacity 라이브러리를 활용한 지수 백오프 재시도 로직 구현. HTTP 상태 코드별 에러 분류, 사용자 정의 예외 클래스 정의. 네트워크 오류, 서버 오류, 인증 오류 등 상황별 처리 전략. 로깅을 통한 에러 추적.",
            "status": "done",
            "testStrategy": "다양한 에러 시나리오 테스트, 재시도 로직 검증, 에러 메시지 정확성 테스트"
          },
          {
            "id": 4,
            "title": "API 응답 데이터 표준화 및 검증 시스템 구현",
            "description": "pydantic을 활용한 응답 데이터 검증 및 표준화된 데이터 모델 정의",
            "dependencies": [
              "2.3"
            ],
            "details": "K-Startup API 응답 스키마에 맞는 pydantic 모델 정의. 응답 데이터 타입 검증, 필수 필드 체크, 데이터 변환 로직 구현. BaseResponse 모델을 상속받는 구조로 일관성 유지. 응답 데이터 정규화 및 null 값 처리.",
            "status": "done",
            "testStrategy": "응답 데이터 검증 테스트, 스키마 일치성 검증, 데이터 변환 로직 테스트"
          },
          {
            "id": 5,
            "title": "K-Startup API 클라이언트 통합 테스트 및 성능 최적화",
            "description": "리팩토링된 클라이언트의 종합적인 테스트와 성능 최적화 작업 수행",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "pytest-asyncio를 활용한 비동기 테스트 스위트 구성. Mock 서버를 통한 API 응답 시뮬레이션, 실제 API 연동 테스트. 응답 시간 측정, 메모리 사용량 모니터링. 병렬 요청 처리 최적화 및 rate limiting 구현.",
            "status": "done",
            "testStrategy": "통합 테스트 실행, 성능 벤치마크 테스트, 메모리 누수 검사, API rate limit 테스트"
          }
        ]
      },
      {
        "id": 3,
        "title": "Repository 패턴 적용 및 데이터 접근 계층 구현",
        "description": "MongoDB 데이터 접근을 위한 Repository 패턴을 적용하고 데이터 접근 계층을 표준화",
        "details": "BaseRepository 추상 클래스를 상속받는 각 도메인별 Repository 클래스 구현. Motor를 활용한 비동기 MongoDB 연산, 트랜잭션 처리, 데이터 검증 및 변환 로직 포함. 페이징, 정렬, 필터링 공통 기능 구현.",
        "testStrategy": "MongoDB 인메모리 테스트 환경 구축, CRUD 연산 테스트, 트랜잭션 테스트, 페이징 및 필터링 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "BaseRepository 추상 클래스 설계 및 구현",
            "description": "MongoDB 데이터 접근을 위한 기본 Repository 추상 클래스를 설계하고 구현합니다. 공통 CRUD 연산, 페이징, 정렬, 필터링 기능을 포함한 베이스 인터페이스를 정의합니다.",
            "dependencies": [],
            "details": "app/repositories/base.py 파일에 BaseRepository 추상 클래스 구현. Motor 비동기 MongoDB 클라이언트를 활용한 기본 CRUD 메서드(create, get_by_id, update, delete, find_many) 정의. 페이징을 위한 PaginationParams 클래스와 SortParams 클래스 구현. 제네릭 타입을 활용하여 다양한 모델에 대응할 수 있도록 설계.",
            "status": "done",
            "testStrategy": "BaseRepository의 각 메서드에 대한 단위 테스트 작성, MongoDB 인메모리 테스트 환경 구축"
          },
          {
            "id": 2,
            "title": "트랜잭션 처리 및 데이터 검증 로직 구현",
            "description": "MongoDB 트랜잭션 처리 기능과 데이터 검증, 변환 로직을 BaseRepository에 통합합니다. 데이터 무결성을 보장하는 트랜잭션 컨텍스트 매니저를 구현합니다.",
            "dependencies": [
              "3.1"
            ],
            "details": "BaseRepository에 with_transaction 데코레이터 또는 컨텍스트 매니저 구현. 데이터 검증을 위한 validate_data 메서드 구현. Pydantic 모델과 MongoDB 문서 간 변환을 위한 to_dict, from_dict 메서드 구현. 에러 핸들링 및 롤백 로직 포함.",
            "status": "done",
            "testStrategy": "트랜잭션 커밋/롤백 테스트, 데이터 검증 실패 시나리오 테스트, 동시성 테스트"
          },
          {
            "id": 3,
            "title": "도메인별 Repository 클래스 구현 - Announcement, DataSource",
            "description": "AnnouncementRepository와 DataSourceRepository 클래스를 BaseRepository를 상속받아 구현합니다. 각 도메인 특성에 맞는 특화된 메서드를 추가합니다.",
            "dependencies": [
              "3.2"
            ],
            "details": "app/repositories/announcement.py에 AnnouncementRepository 구현. 공고 검색, 카테고리별 필터링, 날짜 범위 검색 메서드 구현. app/repositories/data_source.py에 DataSourceRepository 구현. 데이터 소스 상태별 조회, API 키 검증, 엔드포인트 유효성 검사 메서드 구현.",
            "status": "done",
            "testStrategy": "각 Repository의 도메인 특화 메서드 테스트, 실제 데이터를 활용한 통합 테스트"
          },
          {
            "id": 4,
            "title": "고급 검색 및 집계 기능 구현",
            "description": "MongoDB의 집계 파이프라인을 활용한 고급 검색 기능과 텍스트 검색, 다중 조건 필터링 기능을 구현합니다.",
            "dependencies": [
              "3.3"
            ],
            "details": "BaseRepository에 aggregate 메서드 구현으로 복잡한 집계 쿼리 지원. 전문 검색을 위한 text_search 메서드 구현. 다중 조건 필터링을 위한 build_filter_query 헬퍼 메서드 구현. 검색 성능 최적화를 위한 인덱스 힌트 및 explain 기능 추가.",
            "status": "done",
            "testStrategy": "복잡한 집계 쿼리 테스트, 텍스트 검색 정확도 테스트, 다중 필터 조합 테스트"
          },
          {
            "id": 5,
            "title": "Repository 의존성 주입 및 서비스 계층 통합",
            "description": "FastAPI 의존성 주입 시스템을 활용하여 Repository 클래스들을 서비스 계층에 통합합니다. 데이터베이스 연결 관리 및 라이프사이클을 구현합니다.",
            "dependencies": [
              "3.4"
            ],
            "details": "app/dependencies/database.py에 MongoDB 연결 관리 및 Repository 인스턴스 생성 함수 구현. FastAPI Depends를 활용한 의존성 주입 설정. 데이터베이스 연결 풀 관리 및 헬스체크 엔드포인트 구현. 기존 서비스 파일들을 Repository 패턴으로 리팩토링.",
            "status": "done",
            "testStrategy": "의존성 주입 테스트, 데이터베이스 연결 라이프사이클 테스트, 서비스 계층 통합 테스트"
          }
        ]
      },
      {
        "id": 4,
        "title": "의존성 주입 시스템 구축",
        "description": "dependency-injector 또는 FastAPI Depends를 활용한 의존성 주입 시스템 구축",
        "details": "Container 패턴을 활용한 의존성 주입 설정, 서비스와 리포지토리 간의 느슨한 결합 구현. 설정 기반 의존성 관리, 테스트용 Mock 객체 주입 지원. FastAPI의 Depends 시스템과 통합.",
        "testStrategy": "의존성 주입 컨테이너 테스트, Mock 객체 주입 테스트, 순환 의존성 검증",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "의존성 주입 라이브러리 선택 및 기본 설정",
            "description": "dependency-injector와 FastAPI Depends 중 프로젝트에 적합한 의존성 주입 방식을 선택하고 기본 컨테이너 구조를 설정합니다.",
            "dependencies": [],
            "details": "dependency-injector 라이브러리 설치 및 설정, Container 클래스 구현, 기본 의존성 바인딩 설정. pyproject.toml에 의존성 추가하고 app/core/container.py 파일에 DI 컨테이너 구현. Configuration, Database 등 핵심 의존성들을 컨테이너에 등록.",
            "status": "done",
            "testStrategy": "컨테이너 인스턴스화 테스트, 기본 의존성 바인딩 검증"
          },
          {
            "id": 2,
            "title": "서비스 및 리포지토리 의존성 주입 구현",
            "description": "기존 서비스와 리포지토리 클래스들을 의존성 주입 시스템에 통합하고 느슨한 결합을 구현합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "BaseRepository, BaseService 클래스들을 DI 컨테이너에 등록, 생성자 기반 의존성 주입 구현. 서비스 클래스에서 리포지토리를 직접 인스턴스화하지 않고 컨테이너를 통해 주입받도록 수정. app/services와 app/repositories 패키지의 모든 클래스를 DI 시스템에 통합.",
            "status": "done",
            "testStrategy": "서비스-리포지토리 간 의존성 주입 테스트, 순환 의존성 검증"
          },
          {
            "id": 3,
            "title": "FastAPI Depends와 DI 컨테이너 통합",
            "description": "FastAPI의 Depends 시스템과 의존성 주입 컨테이너를 통합하여 API 엔드포인트에서 서비스를 주입받을 수 있도록 구현합니다.",
            "dependencies": [
              "4.2"
            ],
            "details": "app/api/dependencies.py 파일 생성, get_container() 함수 구현하여 FastAPI Depends와 DI 컨테이너 연결. API 라우터에서 Depends를 통해 서비스 인스턴스를 주입받도록 수정. 각 API 엔드포인트 함수의 매개변수로 서비스 의존성을 Depends로 선언.",
            "status": "done",
            "testStrategy": "API 엔드포인트 의존성 주입 테스트, FastAPI 테스트 클라이언트를 통한 통합 테스트"
          },
          {
            "id": 4,
            "title": "환경별 설정 기반 의존성 관리",
            "description": "개발, 테스트, 운영 환경별로 다른 의존성 설정을 관리할 수 있는 시스템을 구현합니다.",
            "dependencies": [
              "4.3"
            ],
            "details": "config/environments 디렉토리에 환경별 설정 파일 생성, Environment enum 클래스 구현. 환경 변수에 따라 다른 DI 설정을 로드하는 ContainerFactory 구현. 데이터베이스, 캐시, 외부 API 클라이언트 등의 환경별 구성을 컨테이너에서 관리.",
            "status": "done",
            "testStrategy": "환경별 컨테이너 설정 테스트, 설정 파일 로딩 검증"
          },
          {
            "id": 5,
            "title": "테스트용 Mock 객체 주입 및 테스트 컨테이너 구현",
            "description": "단위 테스트와 통합 테스트를 위한 Mock 객체 주입 시스템과 테스트 전용 DI 컨테이너를 구현합니다.",
            "dependencies": [
              "4.4"
            ],
            "details": "tests/conftest.py에 테스트용 컨테이너 설정, MockRepository, MockService 클래스들을 테스트 컨테이너에 바인딩. pytest fixture를 통해 테스트별로 다른 Mock 객체를 주입할 수 있도록 구현. unittest.mock과 연동하여 동적 Mock 생성 지원.",
            "status": "done",
            "testStrategy": "Mock 객체 주입 테스트, 테스트 격리성 검증, Mock과 실제 객체 간 인터페이스 일관성 테스트"
          }
        ]
      },
      {
        "id": 5,
        "title": "데이터 소스 관리 시스템 구현",
        "description": "다양한 공공데이터 API를 동적으로 등록하고 관리할 수 있는 시스템 구현",
        "details": "DataSource 모델과 DataSourceRepository 구현. API 키, 엔드포인트, 인증 방식 등 데이터 소스별 설정 관리. 데이터 소스 상태 모니터링, 활성화/비활성화 기능. Factory Pattern을 활용한 데이터 소스별 클라이언트 생성.",
        "testStrategy": "데이터 소스 CRUD 테스트, 설정 검증 테스트, Factory 패턴 테스트",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "DataSource 모델 및 스키마 설계",
            "description": "데이터 소스의 메타데이터와 설정 정보를 저장하기 위한 DataSource 모델과 MongoDB 스키마를 설계하고 구현",
            "dependencies": [],
            "details": "DataSource 모델에 name, type, endpoint_url, api_key, auth_type, status, created_at, updated_at, config(JSON) 필드 포함. BaseDocument를 상속받아 구현하고, 인덱스 설정으로 name과 type에 대한 복합 인덱스 생성. auth_type은 enum으로 API_KEY, OAUTH, BASIC_AUTH 등 지원.",
            "status": "done",
            "testStrategy": "모델 필드 검증 테스트, 스키마 제약조건 테스트, 인덱스 성능 테스트"
          },
          {
            "id": 2,
            "title": "DataSourceRepository 구현",
            "description": "데이터 소스에 대한 CRUD 연산과 검색, 필터링 기능을 제공하는 Repository 패턴 구현",
            "dependencies": [
              "5.1"
            ],
            "details": "BaseRepository를 상속받아 DataSourceRepository 구현. create, read, update, delete, find_by_type, find_active_sources, update_status 메서드 구현. 페이징 및 정렬 기능 포함. 데이터 소스 설정 검증 로직 추가.",
            "status": "done",
            "testStrategy": "CRUD 연산 테스트, 검색 및 필터링 기능 테스트, 예외 처리 테스트"
          },
          {
            "id": 3,
            "title": "데이터 소스 Factory Pattern 구현",
            "description": "데이터 소스 타입별로 적절한 API 클라이언트를 생성하는 Factory 패턴을 구현",
            "dependencies": [
              "5.1"
            ],
            "details": "DataSourceClientFactory 클래스 구현으로 데이터 소스 타입에 따라 적절한 클라이언트 인스턴스를 생성. AbstractFactory 패턴을 활용하여 확장 가능한 구조 구축. 클라이언트 타입별 설정 검증 및 초기화 로직 포함.",
            "status": "done",
            "testStrategy": "Factory 패턴 테스트, 클라이언트 생성 테스트, 타입별 설정 검증 테스트"
          },
          {
            "id": 4,
            "title": "데이터 소스 상태 모니터링 시스템",
            "description": "데이터 소스의 연결 상태와 응답 시간을 모니터링하고 자동으로 상태를 업데이트하는 시스템 구현",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "DataSourceMonitor 클래스로 주기적인 헬스체크 수행. asyncio를 활용한 비동기 상태 확인, 응답시간 측정, 연결 실패 시 재시도 로직. 상태 변경 시 로깅 및 알림 기능. Celery를 활용한 백그라운드 태스크로 구현.",
            "status": "done",
            "testStrategy": "헬스체크 테스트, 상태 업데이트 테스트, 모니터링 스케줄링 테스트"
          },
          {
            "id": 5,
            "title": "데이터 소스 관리 서비스 구현",
            "description": "데이터 소스의 등록, 수정, 삭제, 활성화/비활성화 등 전체적인 관리 기능을 제공하는 서비스 레이어 구현",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "DataSourceService 클래스로 비즈니스 로직 구현. 데이터 소스 등록 시 설정 검증, 중복 체크, 테스트 연결 수행. 활성화/비활성화 시 의존성 확인. 설정 변경 시 관련 캐시 무효화. 트랜잭션 처리로 데이터 일관성 보장.",
            "status": "done",
            "testStrategy": "서비스 메서드 단위 테스트, 비즈니스 로직 검증 테스트, 트랜잭션 테스트"
          }
        ]
      },
      {
        "id": 6,
        "title": "통합 API 클라이언트 프레임워크 구현",
        "description": "다양한 공공데이터 API를 통합하여 호출할 수 있는 확장 가능한 클라이언트 프레임워크 구현",
        "details": "APIClientFactory를 통한 데이터 소스별 클라이언트 생성, 공통 인증 처리, Rate Limiting, Circuit Breaker 패턴 적용. 응답 캐싱, 재시도 로직, 에러 처리 표준화. asyncio를 활용한 비동기 처리.",
        "testStrategy": "다양한 API 클라이언트 통합 테스트, Rate Limiting 테스트, Circuit Breaker 테스트, 캐싱 테스트",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "APIClientFactory 및 클라이언트 레지스트리 구현",
            "description": "다양한 데이터 소스별 API 클라이언트를 생성하고 관리하는 팩토리 패턴과 레지스트리 시스템 구현",
            "dependencies": [],
            "details": "APIClientFactory 클래스를 구현하여 데이터 소스 타입에 따른 적절한 클라이언트 인스턴스 생성. 클라이언트 레지스트리를 통한 싱글톤 패턴 적용으로 인스턴스 재사용. 설정 기반 클라이언트 초기화 및 동적 클라이언트 등록 기능. typing 모듈을 활용한 제네릭 타입 지원.",
            "status": "done",
            "testStrategy": "팩토리 패턴 테스트, 클라이언트 레지스트리 테스트, 동적 등록 기능 테스트"
          },
          {
            "id": 2,
            "title": "공통 인증 처리 및 자격 증명 관리 시스템 구현",
            "description": "다양한 API의 인증 방식을 통합 처리하는 인증 관리 시스템 구현",
            "dependencies": [
              "6.1"
            ],
            "details": "API Key, OAuth2, JWT 등 다양한 인증 방식 지원하는 AuthenticationManager 구현. 자격 증명 보안 저장 및 관리, 토큰 자동 갱신 로직. 환경 변수 및 설정 파일 기반 인증 정보 관리. 인증 실패 시 재시도 및 오류 처리 로직.",
            "status": "done",
            "testStrategy": "다양한 인증 방식 테스트, 토큰 갱신 테스트, 인증 실패 시나리오 테스트"
          },
          {
            "id": 3,
            "title": "Rate Limiting 및 Circuit Breaker 패턴 구현",
            "description": "API 호출 제한 관리와 장애 방지를 위한 Rate Limiting 및 Circuit Breaker 시스템 구현",
            "dependencies": [
              "6.2"
            ],
            "details": "Token Bucket 알고리즘 기반 Rate Limiter 구현, API별 호출 제한 설정. Circuit Breaker 패턴으로 연속 실패 시 자동 차단 및 복구 로직. 백오프 전략과 jitter 적용한 재시도 메커니즘. 상태 모니터링 및 메트릭 수집 기능.",
            "status": "done",
            "testStrategy": "Rate Limiting 동작 테스트, Circuit Breaker 상태 전환 테스트, 복구 로직 테스트"
          },
          {
            "id": 4,
            "title": "응답 캐싱 및 재시도 로직 구현",
            "description": "API 응답 캐싱 시스템과 지능형 재시도 로직 구현으로 성능 및 안정성 향상",
            "dependencies": [
              "6.3"
            ],
            "details": "Redis 기반 응답 캐싱 시스템 구현, TTL 및 캐시 키 전략 설정. 지수 백오프와 최대 재시도 횟수 제한하는 재시도 로직. 캐시 미스 시 API 호출 및 결과 캐싱, 캐시 무효화 전략. 응답 데이터 압축 및 직렬화 최적화.",
            "status": "done",
            "testStrategy": "캐싱 히트/미스 테스트, 재시도 로직 테스트, 캐시 무효화 테스트"
          },
          {
            "id": 5,
            "title": "비동기 처리 및 에러 처리 표준화 구현",
            "description": "asyncio 기반 비동기 API 호출 처리와 통합된 에러 처리 시스템 구현",
            "dependencies": [
              "6.4"
            ],
            "details": "asyncio와 aiohttp를 활용한 비동기 API 클라이언트 구현. 동시 호출 제한 및 세마포어 기반 동시성 제어. 표준화된 예외 클래스 정의 및 에러 코드 매핑. 구조화된 로깅과 에러 추적, 타임아웃 처리 및 연결 풀 관리.",
            "status": "done",
            "testStrategy": "비동기 호출 테스트, 동시성 제어 테스트, 에러 처리 시나리오 테스트, 타임아웃 테스트"
          }
        ]
      },
      {
        "id": 7,
        "title": "데이터 처리 파이프라인 구현",
        "description": "수집된 데이터의 정규화, 검증, 변환을 위한 데이터 처리 파이프라인 구현",
        "details": "Pipeline Pattern을 활용한 데이터 처리 단계 구현. 데이터 정규화, 중복 제거, 품질 검증, enrichment 처리. Pydantic을 활용한 데이터 모델 검증, 데이터 변환 로직 모듈화. 비동기 파이프라인 처리.",
        "testStrategy": "파이프라인 단계별 테스트, 데이터 변환 테스트, 중복 제거 테스트, 검증 로직 테스트",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "데이터 검증 및 정규화 모듈 구현",
            "description": "Pydantic 기반 데이터 모델을 정의하고 입력 데이터의 검증 및 정규화를 수행하는 모듈을 구현합니다.",
            "dependencies": [],
            "details": "Pydantic BaseModel을 상속받은 데이터 스키마 클래스들을 정의합니다. 필드 검증 규칙, 타입 변환, 기본값 설정을 포함합니다. 데이터 정규화를 위한 validator 함수들을 구현하고, 잘못된 데이터 형식에 대한 예외 처리를 추가합니다. src/pipeline/validation.py와 src/models/pipeline.py 파일을 생성합니다.",
            "status": "done",
            "testStrategy": "다양한 입력 데이터 형식에 대한 검증 테스트, 정규화 결과 검증, 예외 상황 처리 테스트"
          },
          {
            "id": 2,
            "title": "중복 제거 및 데이터 품질 검증 모듈 구현",
            "description": "데이터 중복을 감지하고 제거하며, 데이터 품질을 검증하는 모듈을 구현합니다.",
            "dependencies": [
              "7.1"
            ],
            "details": "해시 기반 중복 감지 알고리즘을 구현하고, 필드별 유사도 검사 로직을 추가합니다. 데이터 완성도, 일관성, 정확성을 검증하는 품질 검사 함수들을 구현합니다. 품질 점수 계산 및 임계값 기반 필터링 기능을 포함합니다. src/pipeline/quality.py 파일을 생성합니다.",
            "status": "done",
            "testStrategy": "중복 데이터 감지 정확도 테스트, 품질 점수 계산 검증, 필터링 로직 테스트"
          },
          {
            "id": 3,
            "title": "데이터 변환 및 enrichment 처리 모듈 구현",
            "description": "데이터 형식 변환과 추가 정보 보강을 수행하는 enrichment 모듈을 구현합니다.",
            "dependencies": [
              "7.2"
            ],
            "details": "다양한 데이터 형식 간 변환 함수들을 구현합니다. 외부 API나 참조 데이터를 활용한 데이터 보강 로직을 추가합니다. 지리 정보 표준화, 날짜 형식 통일, 카테고리 매핑 등의 변환 규칙을 구현합니다. src/pipeline/enrichment.py 파일을 생성합니다.",
            "status": "done",
            "testStrategy": "데이터 변환 결과 검증, enrichment 정확도 테스트, 외부 의존성 Mock 테스트"
          },
          {
            "id": 4,
            "title": "Pipeline Pattern 기반 처리 엔진 구현",
            "description": "각 처리 단계를 순차적으로 실행하는 Pipeline Pattern 기반의 데이터 처리 엔진을 구현합니다.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3"
            ],
            "details": "Pipeline, PipelineStep 추상 클래스를 정의하고, 각 처리 단계를 체인으로 연결하는 구조를 구현합니다. 단계별 에러 처리, 롤백 메커니즘, 처리 결과 로깅을 포함합니다. 설정 기반으로 파이프라인 구성을 변경할 수 있도록 합니다. src/pipeline/engine.py 파일을 생성합니다.",
            "status": "done",
            "testStrategy": "파이프라인 실행 흐름 테스트, 에러 처리 및 롤백 테스트, 설정 기반 구성 테스트"
          },
          {
            "id": 5,
            "title": "비동기 파이프라인 처리 시스템 구현",
            "description": "대용량 데이터를 효율적으로 처리하기 위한 비동기 파이프라인 시스템을 구현합니다.",
            "dependencies": [
              "7.4"
            ],
            "details": "asyncio를 활용한 비동기 파이프라인 실행기를 구현합니다. 배치 처리, 병렬 처리, 백프레셔 제어 기능을 추가합니다. 처리 진행률 모니터링, 메트릭 수집, 알림 기능을 포함합니다. Celery 또는 asyncio.Queue를 활용한 작업 큐 시스템을 구축합니다. src/pipeline/async_processor.py 파일을 생성합니다.",
            "status": "done",
            "testStrategy": "비동기 처리 성능 테스트, 동시성 테스트, 메모리 사용량 모니터링 테스트"
          }
        ]
      },
      {
        "id": 8,
        "title": "비즈니스 로직 서비스 계층 개선",
        "description": "도메인별 비즈니스 로직을 캡슐화한 서비스 계층을 SOLID 원칙에 따라 개선",
        "details": "AnnouncementService, BusinessService, ContentService 등 도메인별 서비스 클래스 리팩토링. 비즈니스 로직과 데이터 접근 로직 분리, 크로스 도메인 서비스 구현. Command/Query 분리 패턴 적용, 이벤트 기반 아키텍처 고려.",
        "testStrategy": "서비스 계층 단위 테스트, 비즈니스 로직 검증, Mock Repository를 활용한 격리 테스트",
        "priority": "high",
        "dependencies": [
          4,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "도메인별 서비스 인터페이스 정의 및 추상화",
            "description": "각 도메인(공지사항, 사업정보, 콘텐츠)별 서비스 인터페이스를 정의하고 공통 서비스 추상 클래스를 구현",
            "dependencies": [],
            "details": "IAnnouncementService, IBusinessService, IContentService 인터페이스 정의. BaseService 추상 클래스 구현하여 공통 비즈니스 로직 패턴 정의. SOLID 원칙 중 DIP(의존성 역전 원칙) 적용하여 상위 수준 모듈이 하위 수준 모듈에 의존하지 않도록 설계. typing.Protocol을 활용한 덕 타이핑 지원.",
            "status": "done",
            "testStrategy": "인터페이스 계약 검증 테스트, 추상 클래스 구현 테스트"
          },
          {
            "id": 2,
            "title": "Command/Query 분리 패턴 구현",
            "description": "CQRS 패턴을 적용하여 읽기(Query)와 쓰기(Command) 작업을 분리하고 각각의 핸들러 구현",
            "dependencies": [
              "8.1"
            ],
            "details": "Command 클래스(CreateAnnouncementCommand, UpdateBusinessCommand 등)와 Query 클래스(GetAnnouncementQuery, SearchBusinessQuery 등) 정의. CommandHandler와 QueryHandler 인터페이스 구현. 각 도메인별 Command/Query Handler 클래스 구현. 비즈니스 로직과 데이터 접근 로직의 명확한 분리.",
            "status": "done",
            "testStrategy": "Command/Query Handler 단위 테스트, 비즈니스 로직 검증 테스트"
          },
          {
            "id": 3,
            "title": "도메인 서비스 클래스 리팩토링",
            "description": "기존 AnnouncementService, BusinessService, ContentService를 새로운 아키텍처에 맞게 리팩토링",
            "dependencies": [
              "8.1",
              "8.2"
            ],
            "details": "기존 서비스 클래스를 BaseService를 상속받도록 리팩토링. SRP(단일 책임 원칙)에 따라 각 서비스의 책임을 명확히 분리. Repository 패턴을 통해 데이터 접근 로직 분리. OCP(개방-폐쇄 원칙) 적용하여 확장 가능한 구조로 개선. 의존성 주입을 통한 느슨한 결합 구현.",
            "status": "done",
            "testStrategy": "리팩토링된 서비스 클래스 단위 테스트, Mock Repository를 활용한 격리 테스트"
          },
          {
            "id": 4,
            "title": "크로스 도메인 서비스 및 이벤트 시스템 구현",
            "description": "여러 도메인에 걸친 비즈니스 로직을 처리하는 크로스 도메인 서비스와 이벤트 기반 아키텍처 구현",
            "dependencies": [
              "8.3"
            ],
            "details": "도메인 이벤트(DomainEvent) 인터페이스 정의 및 이벤트 버스 구현. 크로스 도메인 서비스(예: DataSyncService, NotificationService) 구현. 이벤트 핸들러를 통한 도메인 간 통신. asyncio를 활용한 비동기 이벤트 처리. 이벤트 소싱 패턴 고려한 아키텍처 설계.",
            "status": "done",
            "testStrategy": "이벤트 발행/구독 테스트, 크로스 도메인 서비스 통합 테스트"
          },
          {
            "id": 5,
            "title": "서비스 계층 통합 테스트 및 검증",
            "description": "개선된 서비스 계층의 통합 테스트 구현 및 전체 아키텍처 검증",
            "dependencies": [
              "8.1",
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "서비스 계층 전체의 통합 테스트 스위트 구현. 비즈니스 로직 시나리오 테스트, 도메인 간 상호작용 테스트. 성능 테스트 및 동시성 테스트. SOLID 원칙 준수 여부 검증. 코드 품질 메트릭 측정 및 리팩토링 효과 검증.",
            "status": "done",
            "testStrategy": "서비스 계층 통합 테스트, 시나리오 기반 테스트, 성능 벤치마크 테스트"
          }
        ]
      },
      {
        "id": 9,
        "title": "지원사업 구분코드 및 카테고리 시스템 구현",
        "description": "docs의 분류 코드 문서를 기반으로 사업구분코드, 사업카테고리, 컨텐츠 분류 시스템 구현",
        "details": "통합코드_지원사업_구분_코드.md, business_category_codes.md, content-category-codes.md를 기반으로 분류 시스템 구현. Enum 클래스 활용, 코드-명칭 매핑, 계층형 카테고리 지원. 검색 및 필터링 기능과 연동.",
        "testStrategy": "분류 코드 검증 테스트, 계층형 카테고리 테스트, 검색 필터링 통합 테스트",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "분류 코드 문서 분석 및 데이터 구조 설계",
            "description": "docs 폴더의 분류 코드 관련 문서들을 분석하고 코드-명칭 매핑 및 계층형 구조를 위한 데이터 모델 설계",
            "dependencies": [],
            "details": "통합코드_지원사업_구분_코드.md, business_category_codes.md, content-category-codes.md 파일들을 읽어서 분류 체계 파악. 사업구분코드, 사업카테고리, 컨텐츠 분류의 계층 관계 및 코드 체계 분석. Pydantic 모델로 CategoryCode, BusinessCategory, ContentCategory 등의 데이터 클래스 설계",
            "status": "done",
            "testStrategy": "문서 파싱 테스트, 데이터 모델 검증 테스트"
          },
          {
            "id": 2,
            "title": "Enum 클래스 기반 분류 코드 모델 구현",
            "description": "분석된 분류 체계를 기반으로 Python Enum 클래스들을 구현하여 타입 안전한 분류 코드 시스템 구축",
            "dependencies": [
              "9.1"
            ],
            "details": "app/models/enums/ 디렉토리에 BusinessTypeCode, BusinessCategory, ContentCategory Enum 클래스 구현. 각 Enum은 코드값과 한글명을 포함하는 튜플 형태로 정의. IntEnum 또는 StrEnum 활용하여 코드-명칭 매핑 지원. 계층형 카테고리의 경우 parent_code 속성 추가",
            "status": "done",
            "testStrategy": "Enum 값 검증 테스트, 코드-명칭 매핑 테스트, 계층 관계 테스트"
          },
          {
            "id": 3,
            "title": "분류 코드 서비스 클래스 구현",
            "description": "분류 코드의 조회, 검색, 계층 탐색 기능을 제공하는 서비스 클래스 구현",
            "dependencies": [
              "9.2"
            ],
            "details": "app/services/category_service.py에 CategoryService 클래스 구현. get_business_types(), get_categories_by_parent(), search_categories() 등의 메서드 제공. 코드로 명칭 조회, 명칭으로 코드 조회, 계층형 카테고리 트리 구성 기능. 캐싱을 위한 데코레이터 적용 준비",
            "status": "done",
            "testStrategy": "서비스 메서드별 단위 테스트, 계층 탐색 로직 테스트"
          },
          {
            "id": 4,
            "title": "분류 코드 API 엔드포인트 구현",
            "description": "분류 코드 조회 및 검색을 위한 FastAPI 엔드포인트들을 구현하여 외부에서 활용 가능하도록 구성",
            "dependencies": [
              "9.3"
            ],
            "details": "app/api/routes/categories.py에 분류 코드 관련 API 엔드포인트 구현. GET /categories/business-types, GET /categories/business-categories, GET /categories/content-categories 등. 쿼리 파라미터를 통한 필터링 및 검색 지원. OpenAPI 스키마 문서화 포함",
            "status": "done",
            "testStrategy": "API 엔드포인트 테스트, 응답 스키마 검증 테스트"
          },
          {
            "id": 5,
            "title": "기존 검색 및 필터링 시스템과 통합",
            "description": "구현된 분류 코드 시스템을 기존의 검색 및 필터링 기능과 통합하여 완전한 분류 기반 검색 제공",
            "dependencies": [
              "9.4"
            ],
            "details": "기존 검색 서비스에 분류 코드 필터링 로직 추가. MongoDB 쿼리에 분류 코드 조건 추가, 집계 파이프라인에서 분류별 통계 제공. 프론트엔드용 분류 트리 구조 API 제공. 검색 결과에 분류 정보 포함하도록 응답 스키마 확장",
            "status": "done",
            "testStrategy": "통합 검색 테스트, 분류 필터링 기능 테스트, 검색 성능 테스트"
          }
        ]
      },
      {
        "id": 10,
        "title": "Celery 태스크 및 스케줄링 시스템 개선",
        "description": "데이터 수집 및 처리를 위한 Celery 태스크 시스템을 개선하고 스케줄링 기능 강화",
        "details": "데이터 소스별 수집 태스크 모듈화, Celery Beat를 활용한 스케줄링, 태스크 모니터링 및 에러 처리. 병렬 처리 최적화, 태스크 결과 추적, 실패한 태스크 재시도 로직 개선.",
        "testStrategy": "Celery 태스크 단위 테스트, 스케줄링 테스트, 에러 처리 및 재시도 테스트",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "데이터 소스별 Celery 태스크 모듈화",
            "description": "각 데이터 소스(K-Startup, 기타 공공데이터 API)에 대한 독립적인 Celery 태스크를 모듈화하여 관리",
            "dependencies": [],
            "details": "app/tasks/ 디렉토리 하위에 데이터 소스별 태스크 모듈을 생성. BaseTask 클래스를 정의하고 각 데이터 소스별 태스크가 이를 상속받도록 구현. 태스크 간 의존성 관리를 위한 메타데이터 추가. 태스크 실행 컨텍스트 및 로깅 표준화.",
            "status": "pending",
            "testStrategy": "각 태스크 모듈의 단위 테스트, 태스크 간 의존성 검증 테스트"
          },
          {
            "id": 2,
            "title": "Celery Beat 스케줄링 시스템 구축",
            "description": "정기적인 데이터 수집을 위한 Celery Beat 기반 스케줄링 시스템 구현",
            "dependencies": [
              "10.1"
            ],
            "details": "celerybeat-schedule 파일을 통한 스케줄 관리. 동적 스케줄 등록/해제 기능 구현. 크론 표현식을 활용한 유연한 스케줄링. 스케줄 충돌 방지 및 태스크 중복 실행 방지 로직. 스케줄 상태 모니터링 대시보드 기초 작업.",
            "status": "pending",
            "testStrategy": "스케줄 등록/해제 테스트, 크론 표현식 파싱 테스트, 중복 실행 방지 테스트"
          },
          {
            "id": 3,
            "title": "태스크 모니터링 및 상태 추적 시스템",
            "description": "실행 중인 태스크의 상태를 실시간으로 모니터링하고 결과를 추적하는 시스템 구현",
            "dependencies": [
              "10.1"
            ],
            "details": "Celery의 result backend를 활용한 태스크 결과 저장. 태스크 실행 상태(PENDING, STARTED, SUCCESS, FAILURE, RETRY) 추적. 태스크 실행 시간, 메모리 사용량 등 메트릭 수집. 태스크 실행 히스토리 및 통계 생성. Flower 또는 커스텀 모니터링 도구 연동.",
            "status": "pending",
            "testStrategy": "태스크 상태 변화 추적 테스트, 메트릭 수집 검증 테스트, 모니터링 도구 연동 테스트"
          },
          {
            "id": 4,
            "title": "에러 처리 및 재시도 로직 개선",
            "description": "태스크 실패 시 에러 처리와 지능적인 재시도 메커니즘 구현",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "exponential backoff를 적용한 재시도 전략. 에러 유형별 재시도 정책 차별화. 최대 재시도 횟수 및 타임아웃 설정. Dead Letter Queue 구현으로 실패한 태스크 별도 관리. 에러 알림 시스템(Slack, 이메일) 연동. 태스크 실패 원인 분석을 위한 상세 로깅.",
            "status": "pending",
            "testStrategy": "다양한 에러 시나리오 테스트, 재시도 로직 검증, Dead Letter Queue 동작 테스트"
          },
          {
            "id": 5,
            "title": "병렬 처리 최적화 및 성능 튜닝",
            "description": "Celery 워커의 병렬 처리 성능을 최적화하고 시스템 리소스 효율성 개선",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "워커 풀 크기 최적화 및 동적 스케일링. 태스크 우선순위 큐 구현. 메모리 집약적 태스크와 CPU 집약적 태스크 분리. 태스크 배치 처리 최적화. 워커 헬스체크 및 자동 재시작 메커니즘. 시스템 리소스 모니터링 및 알람 설정.",
            "status": "pending",
            "testStrategy": "병렬 처리 성능 벤치마크 테스트, 리소스 사용량 모니터링 테스트, 스케일링 동작 검증"
          }
        ]
      },
      {
        "id": 11,
        "title": "RESTful API 엔드포인트 완성 및 표준화",
        "description": "모든 도메인에 대한 완전한 RESTful API 엔드포인트를 구현하고 표준화",
        "details": "공고, 기업, 컨텐츠, 통계 등 모든 도메인 API 완성. RESTful 원칙 준수, 표준 HTTP 상태 코드 사용, 페이징 및 정렬 표준화. API 버저닝 전략 적용, 응답 포맷 통일.",
        "testStrategy": "API 엔드포인트 통합 테스트, HTTP 상태 코드 검증, 페이징 및 정렬 테스트",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "표준 HTTP 응답 포맷 및 상태 코드 체계 구현",
            "description": "모든 API 엔드포인트에서 사용할 표준 HTTP 응답 포맷과 상태 코드 체계를 정의하고 구현",
            "dependencies": [],
            "details": "BaseResponse 클래스 구현으로 success, data, message, errors 필드를 포함한 통일된 응답 구조 정의. HTTP 상태 코드 매핑 테이블 작성(200, 201, 400, 404, 422, 500). 에러 응답을 위한 ErrorResponse 모델과 ValidationErrorResponse 모델 구현. FastAPI의 HTTPException을 확장한 커스텀 예외 클래스들 구현.",
            "status": "done",
            "testStrategy": "응답 포맷 일관성 테스트, HTTP 상태 코드 매핑 검증, 에러 응답 구조 테스트"
          },
          {
            "id": 2,
            "title": "표준 페이징 및 정렬 시스템 구현",
            "description": "모든 리스트 조회 API에서 사용할 표준 페이징 및 정렬 시스템을 구현",
            "dependencies": [
              "11.1"
            ],
            "details": "PaginationParams 클래스로 page, size, sort, order 파라미터 표준화. 기본값 설정(page=1, size=20, sort=id, order=desc). SortParams와 OrderParams Enum 정의. PaginatedResponse 모델로 items, total, page, size, totalPages 포함. MongoDB와 호환되는 skip/limit 변환 로직 구현.",
            "status": "done",
            "testStrategy": "페이징 파라미터 검증 테스트, 정렬 기능 테스트, 페이지네이션 응답 구조 테스트"
          },
          {
            "id": 3,
            "title": "API 버저닝 전략 구현",
            "description": "URL 경로 기반 API 버저닝 시스템을 구현하고 하위 호환성 보장",
            "dependencies": [
              "11.1"
            ],
            "details": "URL 경로에 /api/v1/ 프리픽스 적용. APIRouter에 prefix='/api/v1' 설정. 버전별 라우터 분리 구조 구현. 향후 v2 도입을 위한 확장 가능한 구조 설계. 버전 간 호환성 체크 미들웨어 구현. deprecated API 엔드포인트에 대한 경고 헤더 추가.",
            "status": "done",
            "testStrategy": "버전별 엔드포인트 접근 테스트, 하위 호환성 검증, 버전 헤더 검증 테스트"
          },
          {
            "id": 4,
            "title": "공고 및 기업 도메인 RESTful API 완성",
            "description": "공고(announcements)와 기업(companies) 도메인에 대한 완전한 CRUD RESTful API 엔드포인트 구현",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3"
            ],
            "details": "공고 API: GET /api/v1/announcements (목록조회), GET /api/v1/announcements/{id} (상세조회), POST /api/v1/announcements (생성), PUT /api/v1/announcements/{id} (수정), DELETE /api/v1/announcements/{id} (삭제). 기업 API도 동일한 패턴 적용. 각 엔드포인트에 표준 응답 포맷과 페이징 적용. 검색 쿼리 파라미터 지원(keyword, category, status). 데이터 검증을 위한 Pydantic 모델 정의.",
            "status": "done",
            "testStrategy": "CRUD 기능 통합 테스트, 검색 파라미터 검증 테스트, 데이터 검증 테스트"
          },
          {
            "id": 5,
            "title": "컨텐츠 및 통계 도메인 RESTful API 완성",
            "description": "컨텐츠(contents)와 통계(statistics) 도메인에 대한 완전한 RESTful API 엔드포인트 구현",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "컨텐츠 API: GET /api/v1/contents, POST /api/v1/contents, GET /api/v1/contents/{id}, PUT /api/v1/contents/{id}, DELETE /api/v1/contents/{id}. 통계 API: GET /api/v1/statistics (집계 데이터), GET /api/v1/statistics/summary (요약 통계), GET /api/v1/statistics/trends (트렌드 데이터). 통계 API는 날짜 범위, 그룹핑 옵션 지원. 모든 엔드포인트에 표준 응답 포맷, 페이징, 에러 처리 적용. 캐싱 헤더 추가로 성능 최적화.",
            "status": "done",
            "testStrategy": "컨텐츠 CRUD 테스트, 통계 API 집계 검증 테스트, 캐싱 동작 테스트, 성능 테스트"
          }
        ]
      },
      {
        "id": 12,
        "title": "완전한 OpenAPI(Swagger) 문서화",
        "description": "모든 API 엔드포인트에 대한 완전한 OpenAPI 명세서 작성 및 Swagger UI 구성",
        "details": "FastAPI의 자동 문서화 기능 활용, 상세한 API 설명, 요청/응답 스키마 정의, 예제 데이터 포함. 태그 기반 API 그룹핑, 인증 방식 문서화, 에러 응답 스키마 정의.",
        "testStrategy": "OpenAPI 스키마 검증, 문서 완성도 검증, 예제 데이터 유효성 테스트",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "FastAPI 애플리케이션 기본 OpenAPI 설정 구성",
            "description": "FastAPI 애플리케이션의 기본 OpenAPI 메타데이터와 Swagger UI 설정을 구성합니다.",
            "dependencies": [],
            "details": "main.py에서 FastAPI 앱 인스턴스에 title, description, version, contact, license 등의 OpenAPI 메타데이터를 설정합니다. Swagger UI와 ReDoc의 커스텀 설정(CSS, favicon, 로고 등)을 적용하고, API 문서 접근 경로를 설정합니다. openapi_tags 리스트를 정의하여 API 그룹핑을 위한 태그 체계를 구축합니다.",
            "status": "done",
            "testStrategy": "OpenAPI JSON 스키마 유효성 검증, Swagger UI 접근성 테스트, 메타데이터 정보 확인"
          },
          {
            "id": 2,
            "title": "Pydantic 모델 스키마 정의 및 예제 데이터 추가",
            "description": "모든 API 요청/응답에 대한 Pydantic 모델을 정의하고 상세한 스키마 정보와 예제 데이터를 추가합니다.",
            "dependencies": [
              "12.1"
            ],
            "details": "각 도메인별로 Request/Response Pydantic 모델을 정의하고, Field 함수를 사용하여 description, example, constraints를 상세히 작성합니다. Config 클래스에서 schema_extra를 활용하여 전체 모델의 예제를 정의합니다. 공통 응답 모델(BaseResponse, ErrorResponse, PaginatedResponse)을 정의하고 재사용 가능하도록 구성합니다.",
            "status": "done",
            "testStrategy": "Pydantic 모델 유효성 검증, 예제 데이터 스키마 일치성 테스트, 직렬화/역직렬화 테스트"
          },
          {
            "id": 3,
            "title": "API 엔드포인트 상세 문서화 및 태그 분류",
            "description": "모든 API 엔드포인트에 상세한 설명, 태그, 응답 상태 코드 등을 추가하여 완전한 문서화를 구현합니다.",
            "dependencies": [
              "12.2"
            ],
            "details": "각 라우터 함수에 @router.get, @router.post 등의 데코레이터에 summary, description, tags, response_description 파라미터를 추가합니다. responses 파라미터를 통해 다양한 HTTP 상태 코드별 응답 스키마를 정의합니다. operation_id를 설정하여 고유한 API 식별자를 부여하고, deprecated 마킹이 필요한 API는 적절히 표시합니다.",
            "status": "done",
            "testStrategy": "API 엔드포인트 문서 완성도 검증, 태그 분류 정확성 테스트, 응답 스키마 일치성 확인"
          },
          {
            "id": 4,
            "title": "인증 및 보안 스키마 문서화",
            "description": "API의 인증 방식과 보안 요구사항을 OpenAPI 스키마에 문서화합니다.",
            "dependencies": [
              "12.3"
            ],
            "details": "FastAPI의 Security 스키마를 활용하여 JWT Bearer Token, API Key 등의 인증 방식을 정의합니다. HTTPBearer, HTTPBasic, APIKeyHeader 등의 보안 스키마를 설정하고, 각 엔드포인트에 필요한 보안 요구사항을 dependencies 파라미터로 지정합니다. OpenAPI에서 Authorization 헤더와 보안 스코프를 명확히 문서화합니다.",
            "status": "done",
            "testStrategy": "보안 스키마 정의 검증, 인증 필요 엔드포인트 문서화 확인, 보안 요구사항 정확성 테스트"
          },
          {
            "id": 5,
            "title": "에러 응답 스키마 정의 및 최종 문서 검증",
            "description": "표준화된 에러 응답 스키마를 정의하고 전체 OpenAPI 문서의 완성도를 검증합니다.",
            "dependencies": [
              "12.4"
            ],
            "details": "HTTPException을 확장한 커스텀 예외 클래스들과 대응하는 에러 응답 Pydantic 모델을 정의합니다. 400, 401, 403, 404, 422, 500 등 주요 HTTP 에러 상태에 대한 표준 응답 스키마를 작성하고, exception_handler를 통해 일관된 에러 응답 형식을 보장합니다. OpenAPI JSON 스키마의 완성도를 검증하고 누락된 문서화 요소를 보완합니다.\n<info added on 2025-07-27T00:32:20.036Z>\n작업 완료 보고서:\n\n**에러 응답 스키마 시스템 구축 완료**\napp/shared/schemas/http_responses.py 파일을 생성하여 HTTP 상태 코드별 표준화된 에러 응답 스키마를 구현했습니다. BadRequestResponse(400), UnauthorizedResponse(401), ForbiddenResponse(403), NotFoundResponse(404), ConflictResponse(409), RateLimitResponse(429), InternalServerErrorResponse(500), ServiceUnavailableResponse(503) 등 8개의 주요 에러 응답 모델을 정의했습니다.\n\n**공통 HTTP 응답 딕셔너리 표준화**\nCOMMON_HTTP_RESPONSES, READ_ONLY_HTTP_RESPONSES, WRITE_HTTP_RESPONSES 등 세 가지 응답 딕셔너리를 정의하여 엔드포인트 유형에 따른 적절한 응답 스키마 그룹을 제공합니다. 이를 통해 라우터에서 일관된 에러 응답 문서화가 가능해졌습니다.\n\n**전체 라우터 응답 스키마 적용**\nannouncements 도메인의 모든 엔드포인트에 표준화된 HTTP 응답 스키마를 적용하여 Swagger UI에서 완전한 에러 응답 문서를 확인할 수 있습니다. GET 요청에는 READ_ONLY_HTTP_RESPONSES를, POST/PUT/DELETE 요청에는 WRITE_HTTP_RESPONSES를 적용했습니다.\n\n**OpenAPI 스키마 커스터마이징 완료**\n보안 스키마 통합, 서버 정보 추가, 외부 문서 링크 설정 등 OpenAPI 스키마의 메타데이터를 완성했습니다. 이로써 완전한 API 문서화 작업이 모두 완료되었으며, Swagger UI(http://localhost:8000/docs)에서 전체 API 명세를 확인할 수 있습니다.\n</info added on 2025-07-27T00:32:20.036Z>",
            "status": "done",
            "testStrategy": "에러 응답 스키마 검증, OpenAPI 스키마 완성도 테스트, Swagger UI 기능 테스트, 문서 일관성 검증"
          }
        ]
      },
      {
        "id": 13,
        "title": "통합 검색 및 고급 필터링 기능 구현",
        "description": "다양한 데이터 소스를 통합하여 검색하고 고급 필터링을 제공하는 기능 구현",
        "details": "Elasticsearch 또는 MongoDB 텍스트 인덱스를 활용한 전문 검색, 다중 조건 필터링, 정렬 및 페이징. 검색 성능 최적화, 검색 결과 하이라이팅, 자동완성 기능. 검색 분석 및 로깅.",
        "testStrategy": "검색 기능 테스트, 필터링 조합 테스트, 성능 테스트, 검색 정확도 테스트",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Elasticsearch/MongoDB 텍스트 검색 인덱스 설정 및 기본 검색 엔진 구현",
            "description": "Elasticsearch 또는 MongoDB 텍스트 인덱스를 설정하고 기본적인 전문 검색 기능을 구현합니다. 검색 엔진 선택, 인덱스 구조 설계, 기본 검색 쿼리 구현을 포함합니다.",
            "dependencies": [],
            "details": "Elasticsearch 또는 MongoDB Atlas Search 중 선택하여 설치 및 설정. 데이터 소스별 인덱스 스키마 정의, 텍스트 분석기 설정, 한국어 형태소 분석기 적용. BaseSearchEngine 추상 클래스 구현 후 구체적인 검색 엔진 클래스 작성. 기본적인 키워드 검색, 구문 검색, 와일드카드 검색 기능 구현.",
            "status": "pending",
            "testStrategy": "검색 엔진 연결 테스트, 인덱스 생성/삭제 테스트, 기본 검색 쿼리 정확도 테스트"
          },
          {
            "id": 2,
            "title": "다중 조건 필터링 시스템 구현",
            "description": "날짜 범위, 카테고리, 지역, 금액 등 다양한 조건을 조합할 수 있는 고급 필터링 시스템을 구현합니다.",
            "dependencies": [
              "13.1"
            ],
            "details": "FilterBuilder 클래스를 통한 동적 필터 쿼리 생성. 범위 필터(날짜, 금액), 정확 매치 필터(카테고리, 상태), 다중 선택 필터 구현. Boolean 조합(AND, OR, NOT) 지원. 필터 조건 검증 및 최적화. FastAPI의 Query 파라미터를 활용한 필터 파싱.",
            "status": "pending",
            "testStrategy": "단일 필터 테스트, 다중 필터 조합 테스트, 잘못된 필터 조건 처리 테스트"
          },
          {
            "id": 3,
            "title": "검색 결과 정렬, 페이징 및 하이라이팅 기능 구현",
            "description": "검색 결과의 정렬, 페이징 처리 및 검색어 하이라이팅 기능을 구현하여 사용자 경험을 향상시킵니다.",
            "dependencies": [
              "13.2"
            ],
            "details": "관련도, 날짜, 인기도 등 다양한 정렬 옵션 구현. 커서 기반 페이징과 오프셋 기반 페이징 지원. 검색 결과에서 검색어 하이라이팅 기능 구현. 검색 결과 요약 정보(총 개수, 소요 시간) 제공. 검색 결과 캐싱을 위한 키 생성 로직.",
            "status": "pending",
            "testStrategy": "정렬 정확도 테스트, 페이징 경계값 테스트, 하이라이팅 정확도 테스트"
          },
          {
            "id": 4,
            "title": "자동완성 및 검색 추천 기능 구현",
            "description": "사용자 입력에 따른 실시간 자동완성과 인기 검색어, 연관 검색어 추천 기능을 구현합니다.",
            "dependencies": [
              "13.1"
            ],
            "details": "Trie 자료구조 또는 Elasticsearch의 completion suggester를 활용한 자동완성 구현. 사용자 검색 히스토리 기반 개인화된 추천. 인기 검색어 집계 및 실시간 업데이트. 오타 수정 및 유사어 검색 기능. Redis를 활용한 자동완성 캐싱.",
            "status": "pending",
            "testStrategy": "자동완성 정확도 테스트, 응답 속도 테스트, 오타 수정 기능 테스트"
          },
          {
            "id": 5,
            "title": "검색 성능 최적화 및 분석 로깅 시스템 구현",
            "description": "검색 성능을 최적화하고 검색 패턴을 분석할 수 있는 로깅 및 모니터링 시스템을 구현합니다.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "검색 쿼리 최적화 및 인덱스 튜닝. 검색 응답 시간 모니터링 및 성능 메트릭 수집. 사용자 검색 행동 분석을 위한 로깅 시스템 구현. 검색 실패 및 무결과 쿼리 추적. Prometheus, Grafana를 활용한 검색 성능 대시보드 구성. 검색 성능 알림 시스템.",
            "status": "pending",
            "testStrategy": "성능 벤치마크 테스트, 대용량 데이터 검색 테스트, 로그 수집 정확도 테스트"
          }
        ]
      },
      {
        "id": 14,
        "title": "캐싱 및 성능 최적화 시스템 구현",
        "description": "Redis를 활용한 캐싱 전략과 API 응답 성능 최적화 시스템 구현",
        "details": "Redis 기반 다층 캐싱 시스템 구현, API 응답 캐싱, 데이터베이스 쿼리 캐싱. TTL 기반 캐시 만료, 캐시 무효화 전략, 캐시 워밍업. 응답시간 모니터링 및 최적화.",
        "testStrategy": "캐싱 전략 테스트, 캐시 히트율 테스트, 성능 벤치마크 테스트",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Redis 연결 및 기본 캐시 인프라 구축",
            "description": "Redis 서버 연결 설정 및 기본 캐시 매니저 클래스 구현",
            "dependencies": [],
            "details": "redis-py 라이브러리를 사용하여 Redis 연결 풀 설정. CacheManager 클래스 구현으로 기본 get/set/delete 메서드 제공. 연결 상태 모니터링, 재연결 로직, 환경별 Redis 설정(개발/운영) 분리. 캐시 키 네이밍 컨벤션 정의 및 네임스페이스 관리.",
            "status": "pending",
            "testStrategy": "Redis 연결 테스트, 기본 CRUD 작업 테스트, 연결 실패 시나리오 테스트"
          },
          {
            "id": 2,
            "title": "다층 캐싱 전략 및 TTL 관리 시스템 구현",
            "description": "계층별 캐시 전략과 TTL 기반 만료 정책 구현",
            "dependencies": [
              "14.1"
            ],
            "details": "L1(메모리), L2(Redis) 캐싱 계층 구현. 데이터 유형별 TTL 정책 설정(API 응답: 5분, DB 쿼리: 1시간, 정적 데이터: 24시간). 캐시 키 충돌 방지를 위한 해싱 전략. 캐시 압축(gzip) 및 직렬화(pickle/json) 최적화.",
            "status": "pending",
            "testStrategy": "TTL 만료 테스트, 다층 캐시 동기화 테스트, 캐시 적중률 측정 테스트"
          },
          {
            "id": 3,
            "title": "API 응답 캐싱 데코레이터 및 DB 쿼리 캐싱 구현",
            "description": "FastAPI 엔드포인트용 캐싱 데코레이터와 데이터베이스 쿼리 캐싱 시스템 구현",
            "dependencies": [
              "14.2"
            ],
            "details": "@cache_response 데코레이터로 API 엔드포인트 캐싱 자동화. 요청 파라미터 기반 캐시 키 생성. MongoDB 쿼리 결과 캐싱을 위한 @cache_query 데코레이터. 사용자별, 권한별 캐시 분리. 조건부 캐싱(ETag, Last-Modified) 지원.",
            "status": "pending",
            "testStrategy": "데코레이터 적용 테스트, 캐시 키 생성 로직 테스트, 조건부 캐싱 동작 테스트"
          },
          {
            "id": 4,
            "title": "캐시 무효화 및 워밍업 전략 구현",
            "description": "데이터 변경 시 캐시 무효화와 예열 시스템 구현",
            "dependencies": [
              "14.3"
            ],
            "details": "태그 기반 캐시 무효화 시스템 구현. 데이터 수정 시 관련 캐시 자동 삭제. 캐시 워밍업 스케줄러로 주요 데이터 사전 로딩. 패턴 매칭을 통한 일괄 캐시 삭제. 캐시 버전 관리 및 점진적 무효화.",
            "status": "pending",
            "testStrategy": "캐시 무효화 시나리오 테스트, 워밍업 스케줄 테스트, 태그 기반 삭제 테스트"
          },
          {
            "id": 5,
            "title": "캐시 성능 모니터링 및 최적화 대시보드 구현",
            "description": "캐시 히트율, 응답 시간 모니터링 시스템 및 성능 최적화 도구 구현",
            "dependencies": [
              "14.4"
            ],
            "details": "Prometheus 메트릭으로 캐시 히트율, 응답 시간, 메모리 사용량 수집. 캐시 성능 대시보드 엔드포인트 제공. 느린 쿼리 감지 및 자동 캐싱 제안. 캐시 통계 분석 및 최적화 권장사항 생성. 실시간 캐시 상태 모니터링 API.",
            "status": "pending",
            "testStrategy": "메트릭 수집 테스트, 성능 측정 정확성 테스트, 대시보드 데이터 검증 테스트"
          }
        ]
      },
      {
        "id": 15,
        "title": "종합 테스트 및 문서화 완성",
        "description": "전체 시스템의 종합적인 테스트 스위트 구축 및 개발 문서화 완성",
        "details": "단위 테스트, 통합 테스트, E2E 테스트 스위트 완성. pytest를 활용한 테스트 자동화, 코드 커버리지 80% 달성. Q_and_A.md, CLAUDE.local.md 문서 정리, API 명세서 최종 검토, 배포 가이드 작성.",
        "testStrategy": "전체 테스트 스위트 실행, 코드 커버리지 검증, 문서 완성도 검증, 배포 테스트",
        "priority": "high",
        "dependencies": [
          12,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "pytest 기반 단위 테스트 스위트 완성",
            "description": "모든 핵심 모듈과 클래스에 대한 단위 테스트를 작성하고 pytest 프레임워크로 통합",
            "dependencies": [],
            "details": "각 API 클라이언트, 서비스, 리포지토리 클래스의 단위 테스트 작성. pytest fixture를 활용한 테스트 데이터 관리, mock을 통한 외부 의존성 격리, 예외 처리 테스트 포함. pytest-cov를 사용하여 코드 커버리지 측정 환경 구축.",
            "status": "pending",
            "testStrategy": "각 테스트 함수의 독립성 보장, 테스트 실행 시간 최적화, 테스트 데이터 정리"
          },
          {
            "id": 2,
            "title": "통합 테스트 및 E2E 테스트 구현",
            "description": "실제 API 호출과 데이터베이스 연동을 포함한 통합 테스트 및 종단간 테스트 구현",
            "dependencies": [
              "15.1"
            ],
            "details": "Docker Compose를 활용한 테스트 환경 구성, 실제 MongoDB와 Redis 연동 테스트, API 엔드포인트 전체 플로우 테스트. pytest-asyncio를 사용한 비동기 테스트, 테스트 데이터베이스 분리 및 초기화 스크립트 작성.",
            "status": "pending",
            "testStrategy": "테스트 환경 자동 구성, 테스트 데이터 일관성 보장, 테스트 격리"
          },
          {
            "id": 3,
            "title": "코드 커버리지 80% 달성 및 테스트 자동화",
            "description": "전체 코드베이스의 커버리지를 80% 이상 달성하고 CI/CD 파이프라인과 통합",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "pytest-cov를 사용한 커버리지 측정, 커버리지가 낮은 모듈 식별 및 테스트 보완. GitHub Actions 또는 GitLab CI를 통한 자동 테스트 실행, 커버리지 리포트 생성 및 배지 추가. pre-commit 훅을 통한 테스트 강제 실행.",
            "status": "pending",
            "testStrategy": "커버리지 임계값 설정, 테스트 실패 시 빌드 중단, 커버리지 트렌드 모니터링"
          },
          {
            "id": 4,
            "title": "API 명세서 및 개발 문서 완성",
            "description": "FastAPI Swagger 문서, Q_and_A.md, CLAUDE.local.md 등 모든 개발 문서를 최신화하고 완성",
            "dependencies": [
              "15.3"
            ],
            "details": "FastAPI의 자동 문서 생성 기능을 활용한 상세한 API 명세서 작성, 각 엔드포인트의 예시 요청/응답 추가. Q_and_A.md에 자주 묻는 질문과 답변 정리, CLAUDE.local.md에 개발 환경 설정 및 주요 명령어 정리. README.md 업데이트 및 기술 스택 문서화.",
            "status": "pending",
            "testStrategy": "문서 링크 유효성 검증, 코드 예시 실행 가능성 테스트, 문서 일관성 검사"
          },
          {
            "id": 5,
            "title": "배포 가이드 작성 및 배포 테스트",
            "description": "프로덕션 배포를 위한 상세한 가이드 문서 작성 및 배포 프로세스 검증",
            "dependencies": [
              "15.4"
            ],
            "details": "Docker를 활용한 컨테이너화 배포 가이드, 환경 변수 설정 가이드, 데이터베이스 마이그레이션 절차 문서화. 로드 밸런싱, 모니터링, 로깅 설정 가이드 포함. 스테이징 환경에서 전체 배포 프로세스 테스트 및 검증.",
            "status": "pending",
            "testStrategy": "배포 스크립트 실행 테스트, 환경별 설정 검증, 롤백 절차 테스트, 헬스체크 동작 확인"
          }
        ]
      },
      {
        "id": 16,
        "title": "API 명세서와 실제 구현 간의 검증 및 일치성 개선",
        "description": "API 명세서, 문서의 분류 코드, K-Startup API 응답과 실제 구현 간의 불일치를 체계적으로 검증하고 수정하는 작업",
        "details": "Phase 1: 코드 분류 체계 검증 및 수정 - docs/통합코드_지원사업_구분_코드.md와 실제 모델의 사업구분코드 매핑 검증, docs/content-category-codes.md의 콘텐츠 분류와 현재 구현 비교 분석, 불일치하는 코드 체계 통합 및 표준화. Phase 2: API 응답 모델 검증 및 개선 - K-Startup API 실제 응답 필드와 내부 데이터 모델 매핑 검증, 누락된 필드나 잘못된 타입 수정, 데이터 변환 로직 개선. Phase 3: OpenAPI 문서화 검증 - Swagger 문서의 스키마와 실제 API 응답 일치성 확인, 예제 데이터 검증 및 업데이트, 에러 응답 스키마 정확성 검증. Phase 4: 데이터 수집 및 검증 로직 개선 - 외부 API 응답 데이터 검증 로직 강화, 데이터 품질 체크 및 예외 처리 개선, 불일치 데이터 감지 및 로깅 시스템 구축.",
        "testStrategy": "분류 코드 매핑 테스트 - 각 도메인별 분류 코드와 실제 데이터의 일치성 검증. API 응답 스키마 검증 테스트 - 실제 K-Startup API 호출 결과와 내부 모델 매핑 정확성 테스트. OpenAPI 문서 일치성 테스트 - 문서화된 스키마와 실제 API 응답 자동 비교 테스트. 데이터 품질 검증 테스트 - 수집된 데이터의 무결성 및 일관성 검증 테스트 스위트 구축.",
        "status": "pending",
        "dependencies": [
          2,
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "실제 K-Startup API 응답 분석 및 코드 분류 체계 검증",
            "description": "실제 K-Startup API를 호출하여 응답 데이터를 분석하고, docs/통합코드_지원사업_구분_코드.md 및 docs/content-category-codes.md의 분류 코드와 비교하여 불일치 사항을 식별합니다.",
            "dependencies": [],
            "details": "1. 실제 K-Startup API 엔드포인트별 샘플 데이터 수집 (공고, 기업정보, 콘텐츠) 2. 수집된 데이터에서 사용되는 실제 분류 코드 추출 및 분석 3. BusinessCategoryCode enum의 cmrczn_tab1, rd_tab1 등이 실제로 사업화/R&D를 의미하는지 검증 4. ContentTypeCode의 notice_matr, fnd_scs_case 등 실제 사용 형태 확인 5. 불일치 사항을 정리한 검증 보고서 작성",
            "status": "done",
            "testStrategy": "실제 API 호출 테스트를 통한 응답 데이터 수집 및 분류 코드 매핑 정확성 검증"
          },
          {
            "id": 2,
            "title": "분류 코드 enum 및 데이터 모델 수정",
            "description": "16.1에서 식별된 불일치 사항을 바탕으로 BusinessCategoryCode, ContentTypeCode enum을 수정하고, 관련 데이터 모델의 필드를 업데이트합니다.",
            "dependencies": [
              "16.1"
            ],
            "details": "1. BusinessCategoryCode enum을 실제 API 응답에 맞게 재정의 (코드값, 설명, 매핑 관계) 2. ContentTypeCode enum을 docs/content-category-codes.md 기준으로 완전 재작성 3. AnnouncementItem, BusinessItem, ContentItem 모델의 분류 관련 필드 검토 및 수정 4. 기존 데이터와의 호환성을 위한 마이그레이션 로직 고려 5. 변경된 enum을 사용하는 모든 코드 부분 업데이트",
            "status": "done",
            "testStrategy": "수정된 enum 값들이 실제 API 응답과 정확히 매핑되는지 단위 테스트 및 통합 테스트"
          },
          {
            "id": 3,
            "title": "API 응답 모델 필드 검증 및 보완",
            "description": "K-Startup API 명세서의 모든 필드와 현재 내부 모델을 비교하여 누락된 필드를 식별하고 추가하며, 기존 필드의 타입과 alias 매핑을 검증합니다.",
            "dependencies": [
              "16.2"
            ],
            "details": "1. docs/kstartup-api-spec.md와 실제 모델 간 필드 매핑 전수조사 2. AnnouncementItem, BusinessItem 등에 누락된 필드 추가 (예: 추가 메타데이터, 상태 정보) 3. 기존 alias 매핑 검증 (pbanc_sn → announcement_id, entrprse_nm → company_name 등) 4. 필드 타입 정확성 검증 및 수정 (str, int, datetime, Optional 등) 5. Pydantic 모델의 validation 규칙 추가 및 개선",
            "status": "done",
            "testStrategy": "실제 API 응답 데이터로 모델 인스턴스 생성 테스트, 필드 매핑 및 타입 변환 정확성 검증"
          },
          {
            "id": 4,
            "title": "OpenAPI 문서화 완성 및 데이터 검증 로직 강화",
            "description": "Swagger 문서의 완성도를 높이고 실제 API 응답과의 일치성을 확인하며, 데이터 수집 및 검증 로직을 개선합니다.",
            "dependencies": [
              "16.3"
            ],
            "details": "1. 현재 Swagger 문서 완성도 점검 및 누락 부분 보완 2. businesses, contents, statistics 도메인의 기본 API 문서화 추가 3. 예시 데이터와 스키마 설명의 정확성 검증 및 업데이트 4. KStartupAPIClient의 XML/JSON 파싱 로직 정확성 검증 5. 데이터 변환 과정에서의 검증 로직 강화 (필수 필드 누락, 타입 불일치 감지) 6. 데이터 품질 이슈 로깅 및 모니터링 시스템 구축",
            "status": "done",
            "testStrategy": "OpenAPI 스키마 자동 검증 테스트, 데이터 파싱 및 변환 로직 단위 테스트, 데이터 품질 검증 테스트 스위트"
          }
        ]
      },
      {
        "id": 17,
        "title": "Docker Compose 환경 안정화 및 오류 해결",
        "description": "Docker Compose 개발 환경에서 발생하는 컨테이너 오류들을 체계적으로 분석하고 해결하여 안정적인 개발 환경을 구축합니다. 주요 임포트 오류와 순환 참조 문제들이 해결되어 현재 대부분의 서비스가 정상 실행 중입니다.",
        "status": "in-progress",
        "dependencies": [
          3,
          10
        ],
        "priority": "high",
        "details": "Phase 1: 환경 변수 및 설정 통합 - ✅ 완료: config.py와 docker-compose.dev.yml 간의 환경변수 매핑 일치성 확보, MongoDB/Redis 연결 URL을 Docker 네트워크 환경에 맞게 수정. Phase 2: 의존성 주입 시스템 최적화 - ✅ 완료: ValidationErrorResponse 임포트 오류 해결, DataCollectionResult 순환 임포트 문제를 data.py 분리로 해결, FastAPI 보안 스키마 임포트 정상화. Phase 3: Celery 설정 및 태스크 정리 - 🔄 진행중: Celery Beat 스케줄에서 존재하지 않는 태스크 참조 제거 필요, Worker와 Beat 연결은 정상 작동. Phase 4: 미들웨어 및 서비스 시작 최적화 - ✅ 대부분 완료: 컨테이너 시작 순서 및 의존성 관리 개선, Health check 설정 최적화 필요. Phase 5: 로깅 및 모니터링 개선 - 🔄 진행중: Flower 컨테이너 안정화 필요.",
        "testStrategy": "Docker Compose 환경 테스트 - ✅ 검증완료: docker-compose up -d 실행 후 API, Celery Worker/Beat, MongoDB/Redis 정상 시작 확인. 서비스 연결성 테스트 - ✅ 검증완료: API 헬스체크 정상, Swagger UI 접근 가능, Celery 태스크 등록 완료. 환경 변수 매핑 테스트 - ✅ 검증완료: 의존성 주입 시스템 정상 작동. 🔄 남은 테스트: Celery Beat 스케줄 검증, Health check 최적화, Flower 모니터링 환경 안정화 검증.",
        "subtasks": [
          {
            "id": 1,
            "title": "환경 변수 및 설정 통합",
            "description": "config.py와 docker-compose.dev.yml 간의 환경변수 매핑 일치성을 확보하고, MongoDB/Redis 연결 URL을 Docker 네트워크 환경에 맞게 수정합니다.",
            "status": "done",
            "dependencies": [],
            "details": "✅ 완료: app/core/config.py와 docker-compose.dev.yml의 환경변수 매핑 일치 확인. MONGODB_URL과 REDIS_URL의 Docker 네트워크 서비스명 사용 정상화. 의존성 주입 시스템 정상 작동으로 환경 설정 로딩 검증 완료.",
            "testStrategy": "환경변수 로딩 테스트와 각 서비스별 연결 테스트를 통해 설정 정확성을 검증합니다."
          },
          {
            "id": 2,
            "title": "의존성 주입 시스템 최적화",
            "description": "복잡한 의존성 주입으로 인한 초기화 실패 문제를 해결하고 서비스 팩토리 함수들의 Docker 환경 호환성을 개선합니다.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "✅ 완료: ValidationErrorResponse 임포트 오류 해결 (http_responses.py에서 base 모듈 임포트 추가). DataCollectionResult 순환 임포트 문제를 새로운 data.py 파일로 분리하여 해결. FastAPI 보안 스키마 임포트 오류 수정 (HTTPBearer, HTTPBasic 올바른 임포트). 모든 서비스 팩토리 함수 정상 등록 및 작동 확인.",
            "testStrategy": "의존성 그래프 검증과 서비스 초기화 순서 테스트를 통해 안정성을 확인합니다."
          },
          {
            "id": 3,
            "title": "Celery 설정 및 태스크 정리",
            "description": "Celery Beat 스케줄에서 존재하지 않는 태스크 참조를 제거하고 scheduler/tasks.py의 태스크 정의와 beat_schedule을 동기화합니다.",
            "status": "in-progress",
            "dependencies": [
              2
            ],
            "details": "🔄 진행중: Celery Worker와 Beat 컨테이너 정상 실행 확인. Worker와 Beat 간 연결 및 태스크 등록 정상 작동. 남은 작업: app/core/celery.py의 beat_schedule에서 존재하지 않는 태스크 참조 제거 필요. 실제 구현된 태스크만 스케줄에 포함시키는 작업 진행 중.",
            "testStrategy": "Celery Beat 스케줄 검증과 태스크 실행 테스트를 통해 정상 작동을 확인합니다."
          },
          {
            "id": 4,
            "title": "미들웨어 및 서비스 시작 최적화",
            "description": "과도한 미들웨어 스택으로 인한 지연/실패 문제를 해결하고 컨테이너 간 시작 순서 및 의존성 관리를 개선합니다.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "✅ 대부분 완료: API 컨테이너 정상 실행 (healthy 상태). 컨테이너 간 시작 순서 및 의존성 관리 개선 완료. 🔄 남은 작업: Celery Worker의 health check 설정 최적화 필요 (현재 실행 중이지만 health check 이슈 있음).",
            "testStrategy": "컨테이너 시작 순서 테스트와 healthcheck 응답 검증을 통해 안정성을 확인합니다."
          },
          {
            "id": 5,
            "title": "로깅 및 모니터링 개선",
            "description": "컨테이너별 로그 수준을 최적화하고 에러 로그를 정리하여 불필요한 경고를 제거합니다.",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "🔄 진행중: API, Celery Worker/Beat 컨테이너의 로그 출력 정상화 확인. MongoDB, Redis 관련 불필요한 경고 메시지 정리 완료. 🔄 남은 작업: Flower 컨테이너 안정화 필요 (현재 재시작 중), Flower 대시보드를 통한 Celery 모니터링 환경 구성 완료 필요.",
            "testStrategy": "로그 출력 검증과 Flower 대시보드 접속 테스트를 통해 모니터링 환경을 확인합니다."
          }
        ]
      },
      {
        "id": 18,
        "title": "JWT 기반 사용자 인증 및 프로필 시스템 구현",
        "description": "JWT 토큰 기반 인증 시스템과 OAuth 2.0 Google Login을 결합한 하이브리드 인증 시스템을 구현하여 개인화된 서비스 제공 기반을 구축합니다. 로컬 회원가입과 소셜 로그인 사용자를 통합 관리하며, GDPR 준수 개인정보 처리를 보장합니다.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          17
        ],
        "priority": "high",
        "details": "Phase 1: JWT 인증 시스템 구축 - python-jose를 활용한 JWT 토큰 생성/검증, 액세스/리프레시 토큰 구조 설계, 토큰 블랙리스트 관리. FastAPI Security 스키마 적용, OAuth2PasswordBearer 구현. Phase 2: OAuth 2.0 Google Login 통합 - Google OAuth 2.0 클라이언트 설정, authorization code flow 구현, Google 사용자 정보 → JWT 토큰 변환 메커니즘. Phase 3: 하이브리드 사용자 모델 설계 - User 도메인 모델 확장 (email, password_hash, google_id, auth_provider), UserProfile 서브도큐먼트 (업종, 창업단계, 지역, 관심분야), 로컬/소셜 사용자 통합 스키마. Phase 4: 통합 인증 API 엔드포인트 - POST /auth/register (로컬 회원가입), POST /auth/login (로컬 로그인), GET /auth/google (Google OAuth 시작), POST /auth/google/callback (Google 콜백 처리), POST /auth/refresh, POST /auth/logout. Phase 5: 접근 레벨별 권한 시스템 - 익명 사용자 권한, 인증된 사용자 권한, 프리미엄 사용자 권한 분리. GDPR 준수 최소 권한 요청 및 개인정보 처리 동의 관리.",
        "testStrategy": "JWT 토큰 생성/검증 테스트 - 유효/무효 토큰 시나리오, 만료 토큰 처리 테스트. OAuth 2.0 Google Login 테스트 - authorization code flow 전체 과정, 토큰 교환 및 사용자 정보 획득 검증. 하이브리드 인증 테스트 - 로컬/소셜 로그인 혼재 시나리오, 동일 이메일 계정 통합 처리. 권한 시스템 테스트 - 접근 레벨별 API 접근 제어, 권한 승격/하향 플로우. GDPR 준수 테스트 - 개인정보 수집 동의, 데이터 삭제 요청 처리, 최소 권한 원칙 검증. 보안 테스트 - OAuth CSRF 방지, state 파라미터 검증, 토큰 탈취 시나리오 테스트.",
        "subtasks": [
          {
            "id": 1,
            "title": "JWT 인증 시스템 핵심 인프라 구축",
            "description": "python-jose를 활용한 JWT 토큰 생성/검증 시스템과 액세스/리프레시 토큰 구조를 설계하고 구현합니다. 토큰 블랙리스트 관리와 FastAPI Security 스키마를 적용합니다.",
            "status": "pending",
            "dependencies": [],
            "details": "JWT 토큰 생성/검증 유틸리티 함수 구현, 액세스 토큰(15분 만료)과 리프레시 토큰(7일 만료) 구조 설계, Redis 기반 토큰 블랙리스트 관리, OAuth2PasswordBearer 구현, 토큰 페이로드 스키마 정의 및 암호화 키 관리",
            "testStrategy": "JWT 토큰 생성/검증 테스트, 토큰 만료 시나리오 테스트, 블랙리스트 토큰 거부 검증, 암호화 키 순환 테스트"
          },
          {
            "id": 2,
            "title": "OAuth 2.0 Google Login 클라이언트 구현",
            "description": "Google OAuth 2.0 클라이언트를 구현하고 authorization code flow를 통한 사용자 인증 시스템을 구축합니다. Google 사용자 정보를 JWT 토큰으로 변환하는 메커니즘을 포함합니다.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Google OAuth 2.0 클라이언트 설정 (client_id, client_secret, redirect_uri), authorization code flow 구현, state 파라미터 CSRF 방지, Google API를 통한 사용자 정보 획득, Google 사용자 정보 → JWT 토큰 변환 로직, scope 최소화 (openid, email, profile만 요청)",
            "testStrategy": "OAuth authorization flow 전체 과정 테스트, CSRF 방지 state 파라미터 검증, Google API 사용자 정보 획득 테스트, 토큰 변환 로직 정확성 검증"
          },
          {
            "id": 3,
            "title": "하이브리드 사용자 도메인 모델 및 스키마 설계",
            "description": "로컬 회원가입과 소셜 로그인 사용자를 통합 관리할 수 있는 User 도메인 모델을 설계하고, 인증 제공자별 사용자 정보를 효과적으로 관리하는 스키마를 구현합니다.",
            "status": "pending",
            "dependencies": [],
            "details": "User 모델 확장 (email, password_hash, google_id, auth_provider, profile, created_at, is_active), UserProfile 서브도큐먼트 유지 (업종 코드, 창업단계, 지역 코드, 관심분야 태그), 다중 인증 제공자 지원 구조, Pydantic 스키마 확장 (SocialUserCreate, LocalUserCreate, UserResponse), 동일 이메일 계정 통합 로직",
            "testStrategy": "하이브리드 사용자 모델 CRUD 테스트, 동일 이메일 계정 통합 로직 검증, 인증 제공자별 사용자 생성 테스트, 프로필 데이터 일관성 검증"
          },
          {
            "id": 4,
            "title": "통합 인증 API 엔드포인트 구현",
            "description": "로컬 인증과 Google OAuth 2.0 인증을 모두 지원하는 통합 인증 API 엔드포인트를 구현합니다. 기존 bcrypt 비밀번호 해싱 시스템을 유지하면서 소셜 로그인 플로우를 추가합니다.",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "POST /auth/register (로컬 회원가입 + 이메일 중복 체크), POST /auth/login (로컬 로그인), GET /auth/google (Google OAuth 시작), POST /auth/google/callback (Google 콜백 처리 + JWT 토큰 발급), POST /auth/refresh (리프레시 토큰으로 액세스 토큰 갱신), POST /auth/logout (토큰 블랙리스트 등록), 계정 연결 API (로컬 ↔ Google 계정 연결)",
            "testStrategy": "로컬/소셜 로그인 통합 테스트, Google OAuth 콜백 처리 검증, 계정 연결/해제 플로우 테스트, 하이브리드 인증 시나리오 검증"
          },
          {
            "id": 5,
            "title": "사용자 프로필 관리 API 구현",
            "description": "사용자 프로필 조회 및 수정 API를 구현하고, 업종/창업단계/지역 코드 검증과 관심분야 태그 관리 기능을 추가합니다.",
            "status": "pending",
            "dependencies": [
              3,
              4
            ],
            "details": "GET /users/profile (현재 사용자 프로필 조회), PUT /users/profile (프로필 수정), 업종/창업단계/지역 코드 마스터 데이터 검증, 관심분야 태그 자동완성 및 관리, 프로필 완성도 계산 및 표시, 프로필 이미지 업로드 지원",
            "testStrategy": "프로필 CRUD 작업 테스트, 코드 검증 로직 테스트, 관심분야 태그 관리 테스트, 프로필 완성도 계산 정확성 검증, 이미지 업로드 및 저장 테스트"
          },
          {
            "id": 6,
            "title": "접근 레벨별 권한 시스템 및 의존성 주입",
            "description": "익명 사용자, 인증된 사용자, 프리미엄 사용자의 접근 레벨을 구분하는 권한 시스템을 구현하고, get_current_user 의존성 함수와 권한 기반 접근 제어를 구축합니다.",
            "status": "pending",
            "dependencies": [
              1,
              4
            ],
            "details": "get_current_user 의존성 함수 구현 (JWT/OAuth 토큰 통합 검증), get_current_active_user 의존성 함수, 접근 레벨별 권한 데코레이터 (@require_auth, @require_premium), 익명 사용자 제한 API 접근, 인증된 사용자 기본 기능, 프리미엄 사용자 고급 기능 분리",
            "testStrategy": "접근 레벨별 권한 제어 검증, 하이브리드 토큰 검증 로직 테스트, 권한 승격/하향 플로우 검증, 익명/인증/프리미엄 사용자별 API 접근 테스트"
          },
          {
            "id": 7,
            "title": "GDPR 준수 개인정보 처리 및 보안 강화",
            "description": "GDPR 준수를 위한 개인정보 처리 동의 관리, 최소 권한 원칙 적용, 데이터 삭제 요청 처리 시스템을 구현하고 OAuth 보안을 강화합니다.",
            "status": "pending",
            "dependencies": [
              2,
              4,
              6
            ],
            "details": "GDPR 개인정보 수집 동의 관리 시스템, 최소 권한 OAuth scope 요청 (openid, email, profile만), 사용자 데이터 삭제 요청 API (Right to be forgotten), OAuth CSRF 및 state 파라미터 보안 강화, 개인정보 암호화 저장, 보안 감사 로그 (로그인 시도, 권한 변경, 데이터 접근)",
            "testStrategy": "GDPR 동의 관리 플로우 테스트, 데이터 삭제 요청 완전성 검증, OAuth 보안 취약점 테스트, 개인정보 암호화/복호화 검증, 최소 권한 원칙 준수 확인"
          }
        ]
      },
      {
        "id": 19,
        "title": "Contents, Statistics, Businesses 도메인 완성",
        "description": "현재 announcements 도메인만 완성된 상태에서 나머지 세 도메인(contents, statistics, businesses)의 서비스와 라우터를 구현하여 CRUD 작업과 공공데이터 API 연동을 완성합니다.",
        "details": "Phase 1: Contents 도메인 구현 - ContentService 클래스를 BaseService를 상속받아 구현하고, 창업 관련 콘텐츠 정보 관리 로직 구현. contents 라우터에서 GET /api/v1/contents, POST /api/v1/contents, PUT /api/v1/contents/{id}, DELETE /api/v1/contents/{id} 엔드포인트 구현. 콘텐츠 분류 코드 기반 필터링 및 검색 기능 추가. Phase 2: Statistics 도메인 구현 - StatisticsService 클래스 구현으로 창업 통계보고서 정보 관리 기능 구현. statistics 라우터에서 통계 데이터 조회, 생성, 수정, 삭제 API 구현. 통계 데이터 집계 및 분석 로직 포함. Phase 3: Businesses 도메인 구현 - BusinessService 클래스 구현으로 지원사업 정보 관리 기능 구현. businesses 라우터에서 지원사업 CRUD API 구현. 사업구분코드 기반 분류 및 검색 기능 구현. Phase 4: 각 도메인별 스키마 완성 - Pydantic 모델을 활용한 요청/응답 스키마 정의. 각 도메인의 Create, Update, Response 스키마 구현. 입력 검증 및 데이터 변환 로직 추가. Phase 5: 공공데이터 API 연동 구현 - K-Startup API에서 각 도메인별 데이터 수집 로직 구현. 기존 BaseAPIClient를 활용한 API 호출 및 데이터 변환. 각 도메인별 데이터 수집 Celery 태스크 구현.",
        "testStrategy": "도메인별 서비스 계층 단위 테스트 - Contents, Statistics, Businesses 서비스의 CRUD 작업 검증. Repository 패턴을 통한 데이터 접근 테스트. API 라우터 통합 테스트 - 각 도메인의 모든 엔드포인트에 대한 HTTP 요청/응답 테스트. 성공 케이스와 에러 케이스 검증. 스키마 검증 테스트 - Pydantic 모델의 입력 검증 및 데이터 변환 테스트. 잘못된 데이터 입력 시 적절한 에러 반환 검증. 공공데이터 API 연동 테스트 - Mock을 활용한 외부 API 호출 테스트. 데이터 변환 및 저장 로직 검증. E2E 테스트 - 전체 도메인의 데이터 수집부터 API 응답까지의 완전한 플로우 테스트.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          8
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Contents 도메인 서비스 및 라우터 구현",
            "description": "콘텐츠 정보 관리를 위한 ContentService 클래스와 FastAPI 라우터를 구현하고, K-Startup API의 getContentInformation 엔드포인트와 연동합니다.",
            "dependencies": [],
            "details": "BaseService를 상속받아 ContentService 클래스 구현. Content 모델 완성 및 ContentCreate, ContentUpdate, ContentResponse 스키마 정의. contents 라우터에서 GET /api/v1/contents, POST /api/v1/contents, PUT /api/v1/contents/{id}, DELETE /api/v1/contents/{id} 엔드포인트 구현. 콘텐츠 분류 코드(content-category-codes.md) 기반 필터링 기능 추가. getContentInformation API 호출 및 데이터 변환 로직 구현.",
            "status": "pending",
            "testStrategy": "ContentService CRUD 작업 단위 테스트, contents 라우터 엔드포인트 통합 테스트, 콘텐츠 분류 코드 필터링 테스트, K-Startup API 연동 Mock 테스트"
          },
          {
            "id": 2,
            "title": "Statistics 도메인 서비스 및 라우터 구현",
            "description": "창업 통계보고서 정보 관리를 위한 StatisticsService 클래스와 FastAPI 라우터를 구현하고, K-Startup API의 getStatisticalInformation 엔드포인트와 연동합니다.",
            "dependencies": [
              "19.1"
            ],
            "details": "BaseService를 상속받아 StatisticsService 클래스 구현. Statistics 모델 완성 및 StatisticsCreate, StatisticsUpdate, StatisticsResponse 스키마 정의. statistics 라우터에서 통계 데이터 CRUD API 구현. 통계 데이터 집계 및 분석 로직 포함. getStatisticalInformation API 호출 및 데이터 변환 로직 구현. MongoDB aggregation pipeline을 활용한 통계 계산 기능 추가.",
            "status": "pending",
            "testStrategy": "StatisticsService 통계 계산 로직 단위 테스트, statistics 라우터 엔드포인트 통합 테스트, MongoDB aggregation 쿼리 테스트, 통계 데이터 정확성 검증 테스트"
          },
          {
            "id": 3,
            "title": "Businesses 도메인 서비스 및 라우터 구현",
            "description": "지원사업 정보 관리를 위한 BusinessService 클래스와 FastAPI 라우터를 구현하고, K-Startup API의 getBusinessInformation 엔드포인트와 연동합니다.",
            "dependencies": [
              "19.2"
            ],
            "details": "BaseService를 상속받아 BusinessService 클래스 구현. Business 모델 완성 및 BusinessCreate, BusinessUpdate, BusinessResponse 스키마 정의. businesses 라우터에서 지원사업 CRUD API 구현. 사업구분코드(business_category_codes.md) 기반 분류 및 검색 기능 구현. getBusinessInformation API 호출 및 데이터 변환 로직 구현. 지원사업 구분코드 필터링 및 검색 최적화.",
            "status": "pending",
            "testStrategy": "BusinessService CRUD 작업 단위 테스트, businesses 라우터 엔드포인트 통합 테스트, 사업구분코드 필터링 테스트, 지원사업 검색 기능 성능 테스트"
          },
          {
            "id": 4,
            "title": "도메인별 데이터 수집 Celery 태스크 구현",
            "description": "각 도메인(Contents, Statistics, Businesses)의 데이터를 주기적으로 수집하는 Celery 태스크를 구현하고 스케줄링을 설정합니다.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3"
            ],
            "details": "fetch_contents_data, fetch_statistics_data, fetch_businesses_data Celery 태스크 구현. 각 태스크에서 해당 도메인의 서비스를 통해 K-Startup API 호출 및 데이터 저장. Celery Beat을 활용한 주기적 데이터 수집 스케줄 설정. 중복 데이터 처리 및 업데이트 로직 구현. 에러 처리 및 재시도 로직 추가. 데이터 수집 상태 모니터링 및 로깅.",
            "status": "pending",
            "testStrategy": "각 Celery 태스크 단위 테스트, 데이터 중복 처리 로직 테스트, 에러 상황 재시도 테스트, 스케줄링 동작 통합 테스트"
          },
          {
            "id": 5,
            "title": "도메인별 통합 테스트 및 API 문서화 완성",
            "description": "세 도메인의 전체적인 통합 테스트를 수행하고, Swagger 문서화를 완성하여 API 명세를 완전히 작성합니다.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3",
              "19.4"
            ],
            "details": "Contents, Statistics, Businesses 도메인의 전체 워크플로우 통합 테스트 작성. K-Startup API 연동부터 데이터 저장, 조회까지의 E2E 테스트 구현. 각 도메인의 모든 엔드포인트에 대한 Swagger 문서 완성. API 응답 예시 및 에러 코드 문서화. 도메인 간 상호작용 테스트 및 성능 벤치마크 테스트. API 버전 관리 및 하위 호환성 검증.",
            "status": "pending",
            "testStrategy": "E2E 통합 테스트, API 응답 스키마 검증 테스트, 성능 부하 테스트, Swagger 문서 정확성 검증, 도메인 간 데이터 일관성 테스트"
          }
        ]
      },
      {
        "id": 20,
        "title": "지능형 필터링 시스템 개발",
        "description": "사용자의 프로필과 관심사를 기반으로 한 지능형 필터링 시스템을 구현하여 다중 조건 필터링, 사용자 맞춤 자동 필터링, 고급 검색 기능을 제공합니다.",
        "details": "Phase 1: 다중 조건 필터링 로직 구현 - FilterService 클래스를 BaseService를 상속받아 구현하고, 업종(business_category), 지역(region), 창업단계(startup_stage), 예산규모(budget_range), 접수기간(application_period) 기반 복합 필터링 로직 구현. QueryBuilder 클래스로 MongoDB 쿼리 동적 생성 및 최적화. Phase 2: 사용자 프로필 기반 자동 필터링 - UserProfile 모델의 관심 분야와 창업 단계 정보를 활용한 개인화 필터링 알고리즘 구현. 추천 엔진 기반 관련 공고 자동 추출, 사용자 행동 패턴 기반 필터링 가중치 조정. Phase 3: 키워드 기반 전체 텍스트 검색 - MongoDB Atlas Search 또는 Elasticsearch 통합으로 공고 제목, 내용, 기관명에 대한 전체 텍스트 검색 구현. 한국어 형태소 분석 및 유사어 검색 지원, 검색 결과 하이라이팅. Phase 4: 고급 검색 및 정렬 최적화 - 날짜 범위 검색, 예산 규모별 범위 검색, 복합 정렬 조건 지원. 페이지네이션 성능 최적화, 검색 결과 캐싱 시스템 구현. GET /api/v1/search/filter, GET /api/v1/search/recommendations 엔드포인트 구현.",
        "testStrategy": "필터링 로직 단위 테스트 - 각 필터 조건별 MongoDB 쿼리 생성 및 실행 결과 검증. 복합 필터 조건의 AND/OR 논리 연산 정확성 테스트. 사용자 맞춤 필터링 테스트 - 다양한 사용자 프로필에 대한 추천 결과 일관성 검증. A/B 테스트를 통한 추천 알고리즘 효과성 측정. 전체 텍스트 검색 테스트 - 한국어 검색어에 대한 정확도 및 재현율 측정. 검색 성능 벤치마크 테스트 (응답시간 < 500ms). 고급 검색 기능 테스트 - 날짜 범위, 예산 범위 검색의 경계값 테스트. 페이지네이션 및 정렬 기능의 대용량 데이터 처리 성능 테스트. API 통합 테스트 - 검색 API 엔드포인트의 다양한 파라미터 조합 테스트. 검색 결과 JSON 스키마 검증 및 에러 케이스 처리 테스트.",
        "status": "pending",
        "dependencies": [
          18,
          19
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "다중 조건 필터링 로직 및 QueryBuilder 구현",
            "description": "업종, 지역, 창업단계, 예산규모, 접수기간 기반 복합 필터링 로직을 구현하고 MongoDB 쿼리를 동적으로 생성하는 QueryBuilder 클래스를 개발합니다.",
            "dependencies": [],
            "details": "FilterService 클래스를 BaseService를 상속받아 구현하고, 각 필터 조건(business_category, region, startup_stage, budget_range, application_period)에 대한 MongoDB 쿼리 생성 로직을 구현합니다. QueryBuilder 클래스는 Builder 패턴을 사용하여 복합 조건을 AND/OR 논리로 조합하고, 인덱스 최적화를 고려한 쿼리를 생성합니다. 필터 조건별 검증 로직과 기본값 처리를 포함합니다.",
            "status": "pending",
            "testStrategy": "각 필터 조건별 MongoDB 쿼리 생성 검증, 복합 필터 조건의 AND/OR 논리 연산 정확성 테스트, 쿼리 성능 및 인덱스 활용도 측정"
          },
          {
            "id": 2,
            "title": "사용자 프로필 기반 개인화 필터링 알고리즘 구현",
            "description": "UserProfile 모델의 관심 분야와 창업 단계 정보를 활용하여 사용자 맞춤 자동 필터링 알고리즘을 구현하고 추천 엔진을 개발합니다.",
            "dependencies": [
              "20.1"
            ],
            "details": "RecommendationService 클래스를 구현하여 사용자 프로필 정보(관심 분야, 창업 단계, 지역 등)를 기반으로 한 개인화 추천 알고리즘을 개발합니다. 협업 필터링과 콘텐츠 기반 필터링을 결합한 하이브리드 추천 시스템을 구축하고, 사용자 행동 패턴(조회, 북마크, 신청 등)을 기반으로 한 가중치 조정 시스템을 구현합니다. 실시간 개인화 점수 계산 및 캐싱 시스템을 포함합니다.",
            "status": "pending",
            "testStrategy": "다양한 사용자 프로필에 대한 추천 결과 일관성 검증, A/B 테스트를 통한 추천 알고리즘 효과성 측정, 개인화 점수 계산 정확도 테스트"
          },
          {
            "id": 3,
            "title": "전체 텍스트 검색 시스템 구현",
            "description": "MongoDB Atlas Search 또는 Elasticsearch를 활용하여 공고 제목, 내용, 기관명에 대한 전체 텍스트 검색 기능을 구현하고 한국어 형태소 분석을 지원합니다.",
            "dependencies": [
              "20.1"
            ],
            "details": "SearchService 클래스를 구현하여 MongoDB Atlas Search 인덱스 설정 및 전체 텍스트 검색 기능을 개발합니다. 한국어 형태소 분석을 위한 분석기 설정과 유사어 검색, 자동 완성 기능을 구현합니다. 검색 결과 하이라이팅, 스니펫 생성, 연관 검색어 제안 기능을 포함하며, 검색 품질 향상을 위한 동의어 사전과 불용어 처리를 구현합니다.",
            "status": "pending",
            "testStrategy": "한국어 검색어에 대한 정확도 및 재현율 측정, 검색 성능 벤치마크 테스트 (응답시간 < 500ms), 형태소 분석 정확도 검증"
          },
          {
            "id": 4,
            "title": "고급 검색 및 정렬 최적화 시스템 구현",
            "description": "날짜 범위 검색, 예산 규모별 범위 검색, 복합 정렬 조건을 지원하는 고급 검색 기능과 성능 최적화된 페이지네이션 시스템을 구현합니다.",
            "dependencies": [
              "20.2",
              "20.3"
            ],
            "details": "AdvancedSearchService 클래스를 구현하여 날짜 범위(접수 시작일, 마감일), 예산 범위, 복합 정렬 조건(관련도, 마감임박순, 예산순, 등록일순)을 지원하는 검색 시스템을 개발합니다. Cursor 기반 페이지네이션으로 대용량 데이터 처리 성능을 최적화하고, Redis를 활용한 검색 결과 캐싱 시스템을 구현합니다. 검색 통계 수집 및 인기 검색어 분석 기능을 포함합니다.",
            "status": "pending",
            "testStrategy": "날짜 범위, 예산 범위 검색의 경계값 테스트, 페이지네이션 및 정렬 기능의 대용량 데이터 성능 테스트, 캐시 적중률 및 성능 향상 측정"
          },
          {
            "id": 5,
            "title": "필터링 API 엔드포인트 및 통합 서비스 구현",
            "description": "필터링 시스템의 모든 기능을 통합하는 API 엔드포인트를 구현하고 전체 시스템의 성능 최적화 및 모니터링 기능을 완성합니다.",
            "dependencies": [
              "20.1",
              "20.2",
              "20.3",
              "20.4"
            ],
            "details": "FilterRouter 클래스에 GET /api/v1/search/filter, GET /api/v1/search/recommendations, GET /api/v1/search/advanced 엔드포인트를 구현합니다. 통합 필터링 서비스 IntegratedFilterService를 구현하여 모든 필터링 기능을 조합하고, 응답 시간 최적화를 위한 병렬 처리 및 캐싱 전략을 적용합니다. API 사용량 통계, 검색 성능 모니터링, 에러 트래킹 시스템을 구현하고 완전한 Swagger 문서화를 완성합니다.",
            "status": "pending",
            "testStrategy": "전체 API 엔드포인트 통합 테스트, 동시 요청 처리 성능 테스트 (1000+ 동시 요청), 캐시 전략 효과성 검증, API 응답 시간 모니터링 (<200ms 목표)"
          }
        ]
      },
      {
        "id": 21,
        "title": "맞춤형 추천 시스템 구현",
        "description": "사용자 프로필을 분석하여 적합한 지원사업을 자동으로 추천하는 지능형 시스템을 구현하며, 지원 자격 조건 자동 체크와 관심도 점수 계산을 포함합니다.",
        "details": "Phase 1: 추천 알고리즘 설계 - 협업 필터링과 콘텐츠 기반 필터링을 결합한 하이브리드 추천 알고리즘 구현. 사용자 프로필(업종, 창업단계, 지역, 사업형태) 기반 벡터 매칭 시스템 구축. scikit-learn의 cosine similarity와 TF-IDF 벡터화를 활용한 유사도 계산. Phase 2: 자격 조건 검증 엔진 - 지원사업별 자격 조건(연령, 창업기간, 사업형태, 매출규모)을 Rule Engine 패턴으로 구현. 조건식 파서와 검증 로직 모듈화, 동적 조건 추가/수정 지원. Pydantic으로 자격 조건 스키마 정의 및 검증. Phase 3: 관심도 점수 계산 시스템 - 프로필 일치도(40%), 과거 관심 이력(30%), 신청 가능성(20%), 마감일 임박도(10%) 가중치 적용. 사용자 행동 데이터(조회, 북마크, 신청) 기반 관심도 학습. Redis를 활용한 실시간 점수 캐싱 및 업데이트. Phase 4: 추천 결과 랭킹 및 설명 - 다중 기준 의사결정 알고리즘(MCDM) 적용한 최종 랭킹 시스템. 추천 이유 생성 엔진으로 자격 매칭도, 적합성 점수, 유사 공고 정보 제공. A/B 테스트 지원을 위한 추천 결과 버전 관리.",
        "testStrategy": "추천 알고리즘 정확도 테스트 - 다양한 사용자 프로필에 대한 추천 결과의 정밀도(Precision)와 재현율(Recall) 측정. 10-fold 교차 검증을 통한 알고리즘 성능 평가. 자격 조건 검증 테스트 - 실제 지원사업 자격 조건과 시스템 검증 결과 100% 일치성 확인. 경계값 테스트(나이, 매출, 창업기간 등) 및 예외 상황 처리 검증. 관심도 점수 계산 테스트 - 시뮬레이션 데이터로 점수 계산 로직 검증, 사용자 행동 패턴별 점수 변화 추적. 성능 테스트 - 1000명 동시 사용자 대상 추천 생성 시간 < 500ms 목표. Redis 캐싱 효과 측정 및 메모리 사용량 모니터링. A/B 테스트 - 기존 필터링 시스템 대비 추천 시스템의 사용자 만족도 및 클릭률 비교 분석.",
        "status": "pending",
        "dependencies": [
          18,
          20
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "사용자 프로필 기반 벡터 매칭 시스템 구현",
            "description": "사용자 프로필(업종, 창업단계, 지역, 사업형태)을 벡터화하고 TF-IDF와 cosine similarity를 활용한 유사도 계산 시스템을 구현합니다.",
            "dependencies": [],
            "details": "UserProfileVectorizer 클래스 구현으로 사용자 프로필을 수치형 벡터로 변환. scikit-learn의 TfidfVectorizer를 활용한 텍스트 데이터 벡터화. cosine_similarity 함수로 사용자와 지원사업 간 유사도 계산. 업종(40%), 창업단계(25%), 지역(20%), 사업형태(15%) 가중치 적용한 종합 매칭 점수 산출.",
            "status": "pending",
            "testStrategy": "다양한 사용자 프로필 조합에 대한 벡터화 결과 검증. 유사도 계산의 정확성 및 가중치 적용 결과 테스트. 성능 테스트로 1000개 프로필 처리 시간 < 100ms 확인."
          },
          {
            "id": 2,
            "title": "지원 자격 조건 Rule Engine 구현",
            "description": "지원사업별 자격 조건(연령, 창업기간, 사업형태, 매출규모)을 동적으로 검증하는 Rule Engine 패턴 기반 시스템을 구현합니다.",
            "dependencies": [
              "21.1"
            ],
            "details": "EligibilityRuleEngine 클래스 구현으로 조건식 파싱 및 검증 로직 처리. Pydantic으로 자격 조건 스키마 정의 (AgeRule, BusinessTypeRule, RevenueRule 등). 동적 조건 추가/수정을 위한 RuleDefinition 모델 구현. AND/OR 논리 연산자 지원하는 복합 조건 처리 시스템.",
            "status": "pending",
            "testStrategy": "실제 지원사업 자격 조건과 시스템 검증 결과 100% 일치성 확인. 경계값 테스트(나이, 매출, 창업기간 등) 및 예외 상황 처리 검증. 복합 조건식 파싱 및 평가 정확성 테스트."
          },
          {
            "id": 3,
            "title": "관심도 점수 계산 및 캐싱 시스템 구현",
            "description": "프로필 일치도, 과거 관심 이력, 신청 가능성, 마감일 임박도를 종합한 관심도 점수 계산 시스템과 Redis 기반 실시간 캐싱을 구현합니다.",
            "dependencies": [
              "21.1",
              "21.2"
            ],
            "details": "InterestScoreCalculator 클래스로 가중치 기반 점수 계산 로직 구현. 프로필 일치도(40%) + 과거 관심 이력(30%) + 신청 가능성(20%) + 마감일 임박도(10%) 종합 계산. UserBehaviorTracker로 조회/북마크/신청 행동 데이터 수집 및 학습. Redis를 활용한 실시간 점수 캐싱 및 TTL 기반 자동 업데이트.",
            "status": "pending",
            "testStrategy": "시뮬레이션 데이터로 점수 계산 로직 검증. 사용자 행동 패턴별 점수 변화 추적 테스트. Redis 캐싱 성능 및 데이터 일관성 검증. 가중치 변경 시 점수 재계산 정확성 테스트."
          },
          {
            "id": 4,
            "title": "하이브리드 추천 알고리즘 구현",
            "description": "협업 필터링과 콘텐츠 기반 필터링을 결합한 하이브리드 추천 알고리즘을 구현하여 개인화된 지원사업 추천을 제공합니다.",
            "dependencies": [
              "21.1",
              "21.2",
              "21.3"
            ],
            "details": "HybridRecommendationEngine 클래스로 협업 필터링(60%)과 콘텐츠 기반 필터링(40%) 결합. 협업 필터링: 유사 사용자 기반 Matrix Factorization 적용. 콘텐츠 기반: 지원사업 특성과 사용자 프로필 매칭. Cold Start 문제 해결을 위한 인기도 기반 초기 추천. 실시간 피드백 학습으로 추천 정확도 지속 개선.",
            "status": "pending",
            "testStrategy": "추천 알고리즘 정확도 테스트로 정밀도(Precision)와 재현율(Recall) 측정. 10-fold 교차 검증을 통한 알고리즘 성능 평가. Cold Start 사용자 대상 추천 품질 검증. A/B 테스트를 통한 하이브리드 가중치 최적화."
          },
          {
            "id": 5,
            "title": "추천 결과 랭킹 및 설명 생성 시스템 구현",
            "description": "다중 기준 의사결정 알고리즘(MCDM)을 적용한 최종 랭킹 시스템과 추천 이유를 설명하는 해석 가능한 추천 시스템을 구현합니다.",
            "dependencies": [
              "21.1",
              "21.2",
              "21.3",
              "21.4"
            ],
            "details": "MCDMRankingSystem 클래스로 TOPSIS 알고리즘 기반 다중 기준 랭킹 시스템 구현. RecommendationExplainer 클래스로 자격 매칭도, 적합성 점수, 유사 공고 정보 기반 추천 이유 생성. 시각적 설명을 위한 매칭 점수 차트 및 비교 분석 제공. A/B 테스트 지원을 위한 추천 결과 버전 관리 및 성과 추적.",
            "status": "pending",
            "testStrategy": "MCDM 알고리즘 정확성 및 랭킹 일관성 검증. 추천 설명의 논리적 타당성 및 사용자 이해도 테스트. A/B 테스트 버전 관리 시스템 정확성 검증. 추천 성과 지표(CTR, 신청률) 추적 및 분석 테스트."
          }
        ]
      },
      {
        "id": 22,
        "title": "대시보드 데이터 준비 및 개인화 통계 시스템 구현",
        "description": "사용자별 맞춤 대시보드를 위한 데이터 집계, 통계 생성, 트렌드 분석 및 실시간 캐싱 시스템을 구현합니다.",
        "details": "Phase 1: 개인 맞춤 통계 API 구현 - DashboardService 클래스를 BaseService를 상속받아 구현하고, 사용자 프로필 기반 관심 분야별 공고 현황 통계 생성. 업종별, 지역별, 창업단계별 공고 분포 및 지원 현황 분석 API 구현. GET /api/v1/dashboard/personal-stats 엔드포인트로 개인화된 통계 데이터 제공. Phase 2: 트렌드 분석 데이터 집계 로직 - MongoDB Aggregation Pipeline을 활용한 월별/분기별 트렌드 분석 구현. 시계열 데이터 집계로 공고 등록 추이, 지원자 수 변화, 예산 규모 트렌드 분석. TrendAnalyzer 클래스로 모듈화하여 재사용 가능한 트렌드 계산 로직 구현. Phase 3: 경쟁률 및 인기도 계산 알고리즘 - CompetitionRateCalculator 클래스로 공고별 지원자 수 대비 선정 인원 경쟁률 계산. 조회수, 북마크 수, 지원자 수를 가중치로 한 인기도 점수 산출 알고리즘 구현. 실시간 경쟁률 업데이트 및 랭킹 시스템 구축. Phase 4: 분야별/지역별 지원 현황 분석 - CategoryAnalyzer와 RegionAnalyzer 클래스로 분야별/지역별 통계 분석 모듈 구현. 사업 카테고리 코드와 지역 코드 기반 집계 쿼리 최적화. 히트맵 데이터 생성을 위한 지역별 활성도 지수 계산. Phase 5: 대시보드용 실시간 데이터 캐싱 - Redis를 활용한 계층별 캐싱 전략 구현 (사용자별, 전역 통계). 캐시 키 전략 설계 및 TTL 관리, 데이터 변경 시 선택적 캐시 무효화. DashboardCacheManager 클래스로 캐시 생명주기 관리 및 백그라운드 갱신 로직 구현.",
        "testStrategy": "개인 맞춤 통계 API 테스트 - 다양한 사용자 프로필에 대한 통계 데이터 정확성 검증. 관심 분야 설정에 따른 필터링 결과 일치성 테스트. 트렌드 분석 로직 테스트 - 과거 데이터 기반 월별/분기별 트렌드 계산 정확성 검증. 시계열 데이터의 집계 결과와 예상값 비교 테스트. 경쟁률 계산 알고리즘 테스트 - 실제 지원 데이터 기반 경쟁률 계산 로직 검증. 인기도 점수 계산의 가중치 적용 결과 테스트. 지역별/분야별 분석 테스트 - 카테고리 코드와 지역 코드 기반 집계 결과 검증. 히트맵 데이터 생성 정확성 및 시각화 데이터 형식 테스트. 캐싱 시스템 테스트 - 캐시 히트율 측정 및 TTL 만료 시 자동 갱신 검증. 동시 접근 시 캐시 일관성 테스트. 성능 테스트 - 대시보드 로딩 시간 < 1초, 1000명 동시 접근 시 응답시간 측정. 메모리 사용량 및 Redis 캐시 크기 모니터링.",
        "status": "pending",
        "dependencies": [
          18,
          19,
          21
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "개인 맞춤 통계 API 및 DashboardService 구현",
            "description": "사용자 프로필 기반 개인화된 대시보드 통계 API를 구현하여 관심 분야별 공고 현황, 업종별 지역별 분포 분석을 제공합니다.",
            "dependencies": [],
            "details": "DashboardService 클래스를 BaseService를 상속받아 구현하고, 사용자 프로필 기반 관심 분야별 공고 현황 통계 생성. 업종별, 지역별, 창업단계별 공고 분포 및 지원 현황 분석 API 구현. GET /api/v1/dashboard/personal-stats 엔드포인트로 개인화된 통계 데이터 제공. UserProfile과 연동하여 관심 분야 필터링 적용.",
            "status": "pending",
            "testStrategy": "다양한 사용자 프로필에 대한 통계 데이터 정확성 검증, 관심 분야 설정에 따른 필터링 결과 일치성 테스트, API 응답 시간 측정 (<500ms 목표)"
          },
          {
            "id": 2,
            "title": "트렌드 분석 및 시계열 데이터 집계 시스템 구현",
            "description": "MongoDB Aggregation Pipeline을 활용한 월별/분기별 트렌드 분석 로직을 구현하여 공고 등록 추이, 지원자 수 변화, 예산 규모 트렌드를 분석합니다.",
            "dependencies": [
              "22.1"
            ],
            "details": "TrendAnalyzer 클래스로 모듈화하여 재사용 가능한 트렌드 계산 로직 구현. MongoDB Aggregation Pipeline을 활용한 월별/분기별 트렌드 분석 구현. 시계열 데이터 집계로 공고 등록 추이, 지원자 수 변화, 예산 규모 트렌드 분석. 이동평균, 계절성 분석 등 고급 통계 기법 적용.",
            "status": "pending",
            "testStrategy": "과거 데이터 기반 월별/분기별 트렌드 계산 정확성 검증, 시계열 데이터의 집계 결과와 예상값 비교 테스트, 대용량 데이터 처리 성능 테스트"
          },
          {
            "id": 3,
            "title": "경쟁률 및 인기도 계산 알고리즘 구현",
            "description": "공고별 지원자 수 대비 선정 인원 경쟁률 계산과 조회수, 북마크 수, 지원자 수를 기반으로 한 인기도 점수 산출 알고리즘을 구현합니다.",
            "dependencies": [
              "22.1",
              "22.2"
            ],
            "details": "CompetitionRateCalculator 클래스로 공고별 지원자 수 대비 선정 인원 경쟁률 계산. 조회수, 북마크 수, 지원자 수를 가중치로 한 인기도 점수 산출 알고리즘 구현. 실시간 경쟁률 업데이트 및 랭킹 시스템 구축. CategoryAnalyzer와 RegionAnalyzer 클래스로 분야별/지역별 통계 분석 모듈 구현.",
            "status": "pending",
            "testStrategy": "실제 지원 데이터 기반 경쟁률 계산 로직 검증, 인기도 점수 계산의 가중치 적용 결과 테스트, 랭킹 시스템 정확성 검증, 실시간 업데이트 성능 테스트"
          },
          {
            "id": 4,
            "title": "실시간 데이터 캐싱 시스템 구현",
            "description": "Redis를 활용한 계층별 캐싱 전략을 구현하여 대시보드 데이터의 실시간 캐싱, TTL 관리, 선택적 캐시 무효화를 제공합니다.",
            "dependencies": [
              "22.1",
              "22.2",
              "22.3"
            ],
            "details": "DashboardCacheManager 클래스로 캐시 생명주기 관리 및 백그라운드 갱신 로직 구현. Redis를 활용한 계층별 캐싱 전략 구현 (사용자별, 전역 통계). 캐시 키 전략 설계 및 TTL 관리, 데이터 변경 시 선택적 캐시 무효화. 캐시 히트율 모니터링 및 성능 최적화.",
            "status": "pending",
            "testStrategy": "캐시 히트율 측정 (목표: >80%), 캐시 무효화 로직 검증, 동시 접근 시 캐시 일관성 테스트, 백그라운드 갱신 프로세스 안정성 검증"
          }
        ]
      },
      {
        "id": 23,
        "title": "실시간 알림 시스템 기반 구축",
        "description": "사용자 맞춤형 실시간 알림 시스템을 구현하여 이메일, 푸시 알림을 통해 새로운 공고, 마감 임박, 결과 발표 등의 정보를 제공합니다.",
        "details": "Phase 1: 이메일 알림 서비스 구축 - smtplib 또는 SendGrid API를 활용한 SMTP 연동, EmailService 클래스를 BaseService를 상속받아 구현. 이메일 템플릿 엔진(Jinja2) 연동, HTML/텍스트 멀티파트 메일 지원. Phase 2: 알림 설정 관리 시스템 - NotificationPreference 모델 구현으로 사용자별 알림 선호도 설정 관리 (이메일, 푸시, SMS 등). 알림 카테고리별 on/off 설정, 시간대별 알림 차단 기능, 알림 빈도 조절 옵션. Phase 3: 새 공고 등록 시 자동 알림 로직 - Celery 태스크로 새 공고 등록 이벤트 감지 및 자동 알림 발송. 사용자 프로필 기반 관련 공고 필터링, 배치 이메일 발송으로 성능 최적화. Phase 4: 마감일 D-day 알림 스케줄러 - Celery Beat를 활용한 일일 스케줄링으로 마감 임박 공고 검색. D-7, D-3, D-1, D-day 단계별 알림 발송, 사용자별 맞춤 알림 시점 설정. Phase 5: 알림 템플릿 관리 시스템 - NotificationTemplate 모델로 알림 유형별 템플릿 관리, 동적 변수 치환 지원. 관리자 인터페이스를 통한 템플릿 편집 기능, A/B 테스트 지원. Phase 6: 알림 발송 이력 및 통계 - NotificationLog 모델로 발송 이력 추적, 발송 성공/실패 통계, 사용자별 열람률 분석. 대시보드를 통한 알림 성과 모니터링.",
        "testStrategy": "이메일 발송 테스트 - SMTP 연결 및 이메일 전송 성공/실패 시나리오 테스트. 템플릿 렌더링 정확성 및 다양한 이메일 클라이언트 호환성 검증. 알림 설정 관리 테스트 - 사용자별 알림 선호도 CRUD 작업 검증. 알림 카테고리별 필터링 및 시간대별 차단 기능 테스트. Celery 태스크 테스트 - 새 공고 등록 이벤트 감지 및 자동 알림 발송 로직 검증. 마감일 알림 스케줄러의 정확한 타이밍 및 중복 방지 테스트. 템플릿 시스템 테스트 - 동적 변수 치환 정확성 및 다국어 지원 테스트. 템플릿 버전 관리 및 A/B 테스트 기능 검증. 성능 테스트 - 대량 사용자 대상 배치 이메일 발송 성능 (1000건/분). 알림 발송 이력 저장 및 조회 성능 테스트. 통합 테스트 - 전체 알림 플로우 E2E 테스트, 실제 이메일 수신 확인.",
        "status": "pending",
        "dependencies": [
          10,
          18
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "정부 지원사업 데이터 분석 엔진 개발",
        "description": "정부 지원사업 데이터의 심층 분석을 위한 분석 엔진을 구현하여 트렌드 분석, 예산 흐름 분석, 정책 변화 감지 기능을 제공합니다.",
        "details": "Phase 1: 분석 엔진 기본 아키텍처 구축 - AnalyticsEngine 클래스를 BaseService를 상속받아 구현하고, 분석 작업을 위한 데이터 파이프라인 설계. MongoDB Aggregation Pipeline과 Pandas를 활용한 대용량 데이터 처리 최적화. 시계열 분석을 위한 DateTime 인덱스 설정 및 쿼리 최적화. Phase 2: 분야별/지역별 지원 현황 분석 - SectorAnalyzer와 RegionalAnalyzer 클래스로 업종별, 지역별 공고 분포 및 예산 할당 분석 구현. 히트맵 데이터 생성을 위한 지역-분야 매트릭스 계산, 상대적 지원 강도 지수 개발. Plotly/Matplotlib을 활용한 시각화 데이터 생성. Phase 3: 시계열 트렌드 분석 시스템 - TimeSeriesAnalyzer 클래스로 월별/분기별/연별 추세 분석 구현. 이동 평균, 계절성 분해, 추세 예측을 위한 ARIMA 모델 적용. Prophet 라이브러리를 활용한 중장기 예측 모델 구축. Phase 4: 정부 예산 흐름 분석 - BudgetFlowAnalyzer 클래스로 부처별, 사업별 예산 배분 및 변화 추적. 예산 증감률, 신규/폐지 사업 감지, 예산 집중도 분석. Sankey 다이어그램을 위한 예산 흐름 데이터 생성. Phase 5: 정책 변화 감지 및 패턴 분석 - PolicyChangeDetector 클래스로 지원 조건, 선정 기준, 예산 규모 변화 패턴 분석. NLP 기반 공고 내용 유사도 분석으로 정책 방향성 변화 감지. 정책 키워드 추출 및 빈도 분석, 정책 라이프사이클 모델링. Phase 6: 경쟁 강도 및 성공률 분석 - CompetitionAnalyzer 클래스로 지원자 수 대비 선정 비율 분석. 과거 데이터 기반 성공률 예측 모델 구축 (Random Forest, XGBoost 활용). 분야별, 지역별, 기업 규모별 성공률 패턴 분석. Redis를 활용한 분석 결과 캐싱 및 실시간 업데이트 시스템.",
        "testStrategy": "분석 알고리즘 정확성 테스트 - 실제 공고 데이터를 활용한 분야별/지역별 분석 결과 검증. 수동 계산 결과와 시스템 분석 결과 비교를 통한 정확도 확인. 시계열 분석 검증 테스트 - 과거 데이터 기반 예측 모델의 실제 결과 대비 정확도 측정 (MAPE < 15% 목표). 계절성 및 추세 분해 결과의 통계적 유의성 검증. 성능 벤치마크 테스트 - 대용량 데이터(10만건 이상) 처리 시간 측정 및 최적화. MongoDB 집계 쿼리 성능 프로파일링, 인덱스 최적화 효과 검증. 예산 흐름 분석 테스트 - 부처별 예산 변화 추적 로직 검증. 신규/폐지 사업 감지 알고리즘의 정확성 테스트. 정책 변화 감지 테스트 - NLP 기반 정책 유사도 분석의 정밀도 측정. 키워드 추출 및 변화 감지 알고리즘 검증. 예측 모델 성능 테스트 - 성공률 예측 모델의 정확도, 정밀도, 재현율 측정. 교차 검증을 통한 모델 일반화 성능 평가. 시각화 데이터 검증 - 생성된 차트 데이터의 형식 및 정확성 확인. 히트맵, Sankey 다이어그램 데이터 무결성 테스트.",
        "status": "pending",
        "dependencies": [
          19,
          22
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "API 고도화 및 성능 최적화",
        "description": "대량 데이터 처리와 높은 트래픽을 위한 API 성능 최적화 작업을 수행하여 캐싱, 인덱싱, 응답 속도를 개선합니다.",
        "details": "Phase 1: 대용량 데이터 처리 최적화 - 커서 기반 페이지네이션(cursor-based pagination) 구현으로 대용량 데이터셋의 효율적 탐색, MongoDB $skip/$limit 최적화 및 인덱스 활용 개선. PaginationService 클래스로 일관된 페이지네이션 로직 모듈화, 메모리 효율적인 스트리밍 응답 처리. Phase 2: Redis 캐싱 전략 구현 - 쿼리 결과 캐싱을 위한 CacheService 클래스 구현, TTL 설정 및 캐시 무효화 전략 수립. 통계 데이터 캐싱(일간/주간/월간), API 응답 캐싱 레이어 구축. Redis Cluster 준비를 위한 키 네이밍 컨벤션 및 분산 캐싱 고려. Phase 3: MongoDB 인덱스 최적화 - 검색 쿼리 성능 분석 및 복합 인덱스 설계, 텍스트 검색을 위한 full-text 인덱스 구성. explain() 결과 기반 쿼리 최적화, 인덱스 사용률 모니터링 도구 구축. Phase 4: API 응답 최적화 - gzip 압축 활성화, 불필요한 필드 제거를 위한 응답 스키마 최적화. JSON 직렬화 성능 개선(orjson 활용), 응답 크기 모니터링 및 경고 시스템. Phase 5: 비동기 처리 개선 - FastAPI의 async/await 최적화, 동시 요청 처리를 위한 connection pool 튜닝. Celery를 활용한 무거운 작업 비동기 처리, 백그라운드 작업 큐 관리. Phase 6: Rate Limiting 고도화 - slowapi를 활용한 정교한 Rate Limiting 구현, IP/사용자별 차등 제한, 버스트 트래픽 대응 전략. API 키 기반 제한, 프리미엄 사용자 우선 처리 로직.",
        "testStrategy": "성능 벤치마크 테스트 - wrk, artillery 등을 활용한 부하 테스트로 동시 요청 1000+ 처리 능력 검증, 응답 시간 200ms 이하 목표 달성 확인. 페이지네이션 성능 테스트 - 10만건 이상 데이터에서 커서 기반 vs offset 기반 페이지네이션 성능 비교, 메모리 사용량 모니터링. 캐싱 효율성 테스트 - Redis 캐시 히트율 측정(목표 80% 이상), TTL 설정 최적화 검증, 캐시 무효화 로직 정확성 테스트. MongoDB 쿼리 성능 테스트 - explain() 결과 분석으로 인덱스 사용률 검증, 복합 쿼리 실행 시간 개선 효과 측정. API 응답 최적화 테스트 - gzip 압축 전후 응답 크기 비교, JSON 직렬화 성능 벤치마크(orjson vs 기본 json). 동시성 테스트 - 동시 사용자 1000명 시뮬레이션, 커넥션 풀 설정 최적화 검증, 메모리 누수 및 리소스 사용량 모니터링. Rate Limiting 테스트 - 제한 임계값 도달 시 정확한 429 응답 반환, 버스트 트래픽 시나리오 테스트, 다양한 Rate Limiting 정책 검증.",
        "status": "pending",
        "dependencies": [
          2,
          3,
          17,
          19
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Phase 1 통합 테스트 및 배포",
        "description": "Phase 1의 모든 기능을 통합하여 테스트하고 프로덕션 환경에 배포하며, 성능 모니터링과 에러 추적 시스템을 설정합니다.",
        "details": "Phase 1: 전체 기능 통합 테스트 - 모든 도메인(announcements, contents, statistics, businesses) API 엔드포인트의 end-to-end 테스트 수행. 인증/인가 시스템의 전체 플로우 검증, 추천 시스템과 API 연동 테스트. 데이터 일관성 및 트랜잭션 무결성 검증. Phase 2: 성능 및 부하 테스트 - wrk, artillery를 활용한 동시 사용자 1000+ 부하 테스트 수행. API 응답 시간 < 200ms(캐시된 데이터), < 2초(실시간 데이터) 목표 달성 검증. MongoDB 쿼리 성능 최적화 및 Redis 캐싱 효율성 측정. Phase 3: 보안 테스트 및 검증 - JWT 토큰 인증, API 키 검증, Rate Limiting 기능 보안 테스트. SQL 인젝션, XSS 등 웹 보안 취약점 스캔. 민감 데이터 암호화 및 로그 보안 검증. Phase 4: 프로덕션 배포 환경 구축 - Docker Compose에서 Kubernetes/Docker Swarm으로 배포 환경 구성. CI/CD 파이프라인(GitHub Actions) 구축으로 자동 빌드/테스트/배포. 무중단 배포를 위한 Blue-Green 또는 Rolling Update 전략 적용. Phase 5: 모니터링 및 알림 시스템 구축 - Prometheus + Grafana를 활용한 시스템 메트릭 모니터링 구축. ELK Stack(Elasticsearch, Logstash, Kibana) 또는 Fluentd 기반 로그 수집/분석 시스템. Sentry 또는 Rollbar를 활용한 실시간 에러 추적 및 알림 시스템 구축.",
        "testStrategy": "통합 테스트 수행 - Postman/Newman을 활용한 전체 API 엔드포인트 자동화 테스트 스위트 작성 및 실행. 사용자 시나리오 기반 end-to-end 테스트로 실제 사용 플로우 검증. 성능 벤치마크 테스트 - 목표 성능 지표(응답시간, 처리량, 동시 사용자) 달성 여부 검증. 메모리 사용량, CPU 사용률, 디스크 I/O 모니터링으로 리소스 최적화 확인. 보안 침투 테스트 - OWASP ZAP 또는 Burp Suite를 활용한 웹 애플리케이션 보안 스캔. 인증 우회, 권한 상승, 데이터 유출 시나리오 테스트. 배포 테스트 - 스테이징 환경에서 프로덕션과 동일한 조건으로 배포 테스트 수행. 롤백 시나리오 테스트 및 데이터 백업/복구 프로세스 검증. 모니터링 시스템 검증 - 의도적 에러 발생을 통한 알림 시스템 작동 확인. 대시보드 메트릭 정확성 및 실시간 모니터링 기능 검증.",
        "status": "pending",
        "dependencies": [
          17,
          19,
          21,
          22,
          23,
          24,
          25
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "웹 대시보드 프론트엔드 개발",
        "description": "Module Federation과 React 18 + Webpack 5를 활용한 마이크로프론트엔드 아키텍처 기반의 반응형 웹 대시보드를 구축하여 도메인별 독립 배포와 OAuth 2.0 Google Login을 지원하는 사용자 맞춤형 플랫폼을 제공합니다.",
        "status": "pending",
        "dependencies": [
          22,
          23,
          25,
          26
        ],
        "priority": "medium",
        "details": "Phase 1: 마이크로프론트엔드 아키텍처 설계 및 Shell 애플리케이션 구축 - React 18 + TypeScript + Webpack 5 Module Federation 기반 프로젝트 초기 설정. Shell 애플리케이션(호스트) 및 Remote 모듈 구조 설계, Federated 모듈 간 의존성 관리 설정. ESLint/Prettier 코드 품질 도구 및 공통 CI/CD 파이프라인 구성. Phase 2: OAuth 2.0 Google Login 통합 인증 모듈 구현 - Google OAuth 2.0 provider 설정 및 JWT 토큰 기반 인증 시스템 구축. 사용자 세션 관리 및 토큰 갱신 로직, 접근 레벨별 라우팅 권한 관리 (익명/인증된 사용자). 공통 인증 컨텍스트 제공 및 마이크로프론트엔드 간 인증 상태 공유. Phase 3: 도메인별 마이크로프론트엔드 모듈 개발 - Announcements 모듈: 공고 목록/상세/필터링 독립 애플리케이션. Businesses 모듈: 지원사업 관리 독립 애플리케이션. Contents 모듈: 콘텐츠 관리 독립 애플리케이션. Dashboard 모듈: 사용자 맞춤형 대시보드 독립 애플리케이션. 각 모듈별 독립적인 빌드/배포 파이프라인 구성. Phase 4: 공통 UI/UX 디자인 시스템 구축 - Module Federation을 통한 공통 디자인 시스템 모듈 구현. Material-UI 또는 Ant Design 기반 공통 컴포넌트 라이브러리. 반응형 레이아웃 및 접근 레벨별 UI/UX 차별화 (익명 사용자는 제한된 기능, 인증된 사용자는 개인화 기능). 다크모드/라이트모드 테마 및 접근성(a11y) 가이드라인 준수. Phase 5: 마이크로프론트엔드 통합 및 라우팅 - Shell 애플리케이션에서 동적 모듈 로딩 및 클라이언트 사이드 라우팅 구현. 모듈 간 이벤트 기반 통신 시스템 및 전역 상태 관리. 모듈별 독립적인 에러 바운더리 및 fallback UI 구현. Phase 6: 성능 최적화 및 PWA 구현 - Module Federation을 통한 코드 스플리팅 및 레이지 로딩 최적화. Service Worker를 활용한 캐싱 전략 및 오프라인 지원. Progressive Web App 기능: 푸시 알림, 홈 화면 추가, 백그라운드 동기화.",
        "testStrategy": "마이크로프론트엔드 아키텍처 테스트 - Module Federation 모듈 로딩 테스트, Shell과 Remote 모듈 간 통신 검증. 모듈별 독립 배포 테스트 및 버전 호환성 검증. 인증 모듈 테스트 - OAuth 2.0 Google Login 플로우 테스트, JWT 토큰 검증 및 갱신 로직 테스트. 접근 레벨별 권한 검증 및 세션 관리 테스트. 도메인별 모듈 테스트 - Jest와 React Testing Library를 활용한 각 마이크로프론트엔드 모듈의 독립적인 단위 테스트. 모듈 간 이벤트 통신 및 상태 공유 테스트. E2E 테스트 - Cypress 또는 Playwright를 활용한 전체 마이크로프론트엔드 통합 시나리오 테스트. 로그인부터 각 도메인 모듈 네비게이션까지 전체 사용자 플로우 검증. 성능 테스트 - Module Federation 번들 크기 최적화 검증, 모듈 로딩 성능 측정. Lighthouse 점수 측정 및 PWA 기능 검증. 접근 레벨별 UI/UX 테스트 - 익명 사용자와 인증된 사용자 간 화면 차이 검증. 반응형 디자인 테스트 (320px~1920px). 배포 및 호환성 테스트 - 각 마이크로프론트엔드 모듈의 독립 배포 검증. 모듈 버전 업데이트 시 하위 호환성 테스트. 브라우저 호환성 테스트 (Chrome, Firefox, Safari, Edge).",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "AI 기반 인사이트 및 예측 분석 시스템 구현",
        "description": "머신러닝과 AI 기술을 활용하여 지원 성공률 예측, 트렌드 분석, 정책 변화 감지 등의 고급 분석 기능을 제공하는 지능형 인사이트 시스템을 구현합니다.",
        "details": "Phase 1: ML 모델 기반 지원 성공률 예측 시스템 - scikit-learn을 활용한 지원 성공률 예측 모델 구현 (RandomForest, XGBoost 앙상블), 기업 규모, 업종, 지역, 과거 지원 이력, 사업계획서 키워드 등을 특성으로 활용. MLPredictionService 클래스를 BaseService를 상속받아 구현하고, 모델 학습/예측/평가 파이프라인 구축. Airflow 또는 Celery Beat를 활용한 주기적 모델 재학습 스케줄링. Phase 2: 시계열 분석 기반 트렌드 예측 - Prophet, ARIMA 모델을 활용한 정부 지원사업 트렌드 예측 시스템 구현. 월별/분기별 공고 수, 예산 규모, 분야별 지원 현황 예측. TimeSeriesPredictionService로 모듈화하여 다양한 시계열 데이터 분석 지원. 계절성, 주기성, 추세 분해를 통한 정확도 향상. Phase 3: 자연어 처리 기반 정책 변화 감지 - transformers 라이브러리와 KoBERT를 활용한 공고 텍스트 분석 시스템 구현. 정책 키워드 추출, 문서 유사도 분석, 변화점 탐지 알고리즘 적용. PolicyChangeDetector 클래스로 신규 정책 방향성 자동 분석 및 알림. Phase 4: 경쟁사 분석 및 유사 기업 매칭 - 기업 프로필 벡터화 (업종, 매출, 직원 수, 설립일 등)를 통한 cosine similarity 기반 유사 기업 탐지. CompetitorAnalysisService로 동일 분야 지원 기업 분석 및 성공 패턴 도출. 협업 필터링을 활용한 유사 기업의 지원 성공 사례 추천. Phase 5: 개인화된 인사이트 리포트 생성 - Jinja2 템플릿을 활용한 동적 리포트 생성 시스템, 사용자별 맞춤 분석 결과 PDF/HTML 형태로 제공. InsightReportGenerator 클래스로 통계 차트, 예측 그래프, 추천 결과 통합. Apache Airflow를 활용한 주기적 리포트 자동 생성 및 배포. Phase 6: A/B 테스트 기반 추천 시스템 개선 - MLflow를 활용한 ML 모델 버전 관리 및 A/B 테스트 프레임워크 구축. 다양한 추천 알고리즘의 성능 비교 및 최적화. ABTestService로 사용자 그룹별 추천 성능 측정 및 개선 사이클 구축. Phase 7: 예측 정확도 모니터링 및 지속적 개선 - Prometheus + Grafana를 활용한 ML 모델 성능 실시간 모니터링. 예측 정확도, 모델 드리프트, 데이터 품질 지표 추적. ModelMonitoringService로 성능 저하 감지 시 자동 재학습 트리거.",
        "testStrategy": "ML 모델 성능 테스트 - 과거 데이터를 활용한 백테스팅으로 지원 성공률 예측 모델의 정확도(>85%), 정밀도, 재현율 검증. 교차 검증(K-fold)을 통한 모델 안정성 확인. 시계열 예측 정확도 테스트 - 3개월 후 트렌드 예측 결과와 실제 데이터 비교를 통한 MAPE(Mean Absolute Percentage Error) < 10% 목표 달성 검증. 계절성 분해 결과의 통계적 유의성 검증. 자연어 처리 성능 테스트 - 정책 변화 감지 알고리즘의 정밀도/재현율 측정, 수동 라벨링 데이터와의 일치도 검증. KoBERT 모델의 한국어 정책 문서 이해도 평가. 유사 기업 매칭 정확도 테스트 - 실제 경쟁사 관계와 시스템 매칭 결과의 일치도 검증. 동일 업종/규모 기업군에서의 매칭 정확도 측정. 리포트 생성 품질 테스트 - 생성된 인사이트 리포트의 데이터 정확성 및 시각화 품질 검증. 다양한 사용자 프로필에 대한 개인화 수준 평가. A/B 테스트 통계적 유의성 검증 - 추천 시스템 개선 효과의 통계적 유의성(p-value < 0.05) 확인. 사용자 만족도 및 클릭률 개선 정도 측정. 시스템 성능 및 확장성 테스트 - 대량 데이터(10만건 이상) 처리 시 ML 모델 추론 시간 < 2초 검증. 동시 다중 사용자 인사이트 요청 처리 성능 테스트.",
        "status": "pending",
        "dependencies": [
          22,
          24,
          25,
          27
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "구독 서비스 및 결제 시스템 구현",
        "description": "프리미엄 구독 모델을 구현하여 수익화를 시작하며, PG사 연동 결제 시스템, 사용자 등급 관리, 프리미엄 기능을 포함합니다.",
        "details": "Phase 1: 구독 플랜 모델 및 스키마 설계 - SubscriptionPlan 모델 구현 (Basic/Premium/Enterprise 플랜), UserSubscription 모델로 사용자별 구독 상태 관리, 플랜별 기능 제한 정보 및 가격 정보 포함. Phase 2: 결제 시스템 PG사 연동 - 토스페이먼츠/KG이니시스 API 클라이언트 구현, PaymentService 클래스를 BaseService를 상속받아 구현, 결제 승인/취소/환불 로직 및 웹훅 처리. Phase 3: 사용자 등급별 접근 제어 시스템 - 권한 기반 미들웨어 구현으로 API 엔드포인트별 구독 등급 확인, 프리미엄 전용 분석 리포트 및 고급 필터링 기능 제한. Decorator 패턴으로 등급별 기능 제한 구현. Phase 4: 구독 관리 API 구현 - POST /api/v1/subscriptions/subscribe (구독 신청), POST /api/v1/subscriptions/cancel (구독 해지), GET /api/v1/subscriptions/plans (플랜 조회), GET /api/v1/subscriptions/history (결제 이력). Phase 5: 프리미엄 전용 기능 구현 - 고급 분석 리포트 (업종별 성공률, 예측 분석), 우선 알림 서비스 (프리미엄 사용자 우선 발송), 무제한 북마크 및 고급 검색 필터. Phase 6: 세금계산서 발행 시스템 - 법인/개인 구분 세금계산서 생성, PDF 생성 및 이메일 발송 기능, 국세청 전자세금계산서 연동 준비.",
        "testStrategy": "결제 시스템 테스트 - PG사 API 연동 테스트 (승인/취소/환불), 웹훅 처리 정확성 검증, 결제 실패 시나리오 및 재시도 로직 테스트. 구독 관리 테스트 - 구독 플랜 변경 및 업그레이드/다운그레이드 시나리오 테스트, 구독 만료 처리 및 자동 갱신 로직 검증. 접근 제어 테스트 - 등급별 API 접근 권한 검증, 프리미엄 기능에 대한 Basic 사용자 접근 차단 테스트, 구독 만료 시 권한 회수 검증. 결제 보안 테스트 - 결제 정보 암호화 및 PCI DSS 준수 검증, 결제 토큰 보안 및 만료 처리 테스트. 세금계산서 발행 테스트 - PDF 생성 정확성 및 법적 요구사항 충족 검증, 이메일 발송 및 다운로드 기능 테스트. 구독 수익 분석 테스트 - 구독별 수익 집계 및 리포트 생성 정확성 검증, 환불 처리 시 수익 조정 로직 테스트.",
        "status": "pending",
        "dependencies": [
          18,
          22,
          23,
          24,
          26
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Phase 3: 커뮤니티 플랫폼 구축",
        "description": "사용자 간 소통과 네트워킹을 위한 커뮤니티 플랫폼을 구축하여 멘토링, 정보 공유, 팀 빌딩 기능을 제공합니다.",
        "details": "Phase 1: 실시간 메시징 시스템 구축 - WebSocket 기반 실시간 채팅 시스템 구현, Socket.IO 또는 FastAPI WebSocket을 활용한 양방향 통신 구현. MessageService 클래스를 BaseService를 상속받아 구현하고, Redis Pub/Sub를 활용한 메시지 브로커링 시스템 구축. 1:1 개인 메시지와 그룹 채팅방 지원, 메시지 읽음 처리 및 실시간 알림 기능. Phase 2: 관심 분야별 커뮤니티 그룹 시스템 - CommunityService와 GroupService 클래스 구현으로 사용자 관심 분야 기반 그룹 생성/관리 기능 구현. 업종별, 창업단계별, 지역별 커뮤니티 자동 분류 시스템, 그룹 가입 승인 및 관리자 권한 관리. Phase 3: 멘토-멘티 매칭 시스템 - MentorshipService 클래스로 멘토 등록 및 멘티 매칭 알고리즘 구현. 경험, 업종, 지역을 기반으로 한 매칭 점수 계산, 멘토링 세션 예약 및 관리 시스템. 평가 시스템을 통한 멘토 신뢰도 관리. Phase 4: 지식 공유 게시판 시스템 - ForumService 클래스로 성공사례, 노하우, Q&A 게시판 구현. 태그 기반 분류 및 검색 기능, 베스트 답변 선정 및 포인트 시스템. 파일 첨부 기능 및 Rich Text Editor 지원. Phase 5: 팀 빌딩 및 프로젝트 매칭 - TeamBuildingService로 공동 지원 프로젝트 팀 구성 기능 구현. 역할별(개발자, 디자이너, 기획자) 팀원 모집 시스템, 프로젝트 관리 도구 연동. Phase 6: 이벤트 및 모임 관리 시스템 - EventService로 온라인/오프라인 모임 개최 기능 구현. 캘린더 연동, 참석자 관리, 알림 시스템. 지역별 네트워킹 이벤트 추천. Phase 7: 평판 및 뱃지 시스템 - ReputationService로 커뮤니티 활동 기반 평판 점수 계산 시스템 구현. 활동별 포인트 적립(게시글 작성, 댓글, 멘토링 등), 레벨 시스템 및 뱃지 획득 조건 설정.",
        "testStrategy": "실시간 메시징 시스템 테스트 - WebSocket 연결 안정성 및 메시지 전송 지연시간(< 100ms) 측정. 동시 접속자 1000명 이상 부하 테스트, 메시지 순서 보장 및 중복 방지 검증. 커뮤니티 그룹 기능 테스트 - 그룹 생성, 가입, 탈퇴 플로우 검증. 권한 관리 및 모더레이션 기능 정확성 테스트. 멘토-멘티 매칭 알고리즘 테스트 - 다양한 프로필 조합에 대한 매칭 정확도 검증. 매칭 점수 계산 로직 및 추천 시스템 성능 테스트. 게시판 시스템 테스트 - CRUD 작업 및 검색 기능 정확성 검증. 태그 시스템 및 베스트 답변 선정 로직 테스트. 팀 빌딩 기능 테스트 - 팀 구성 및 프로젝트 매칭 로직 검증. 역할별 필터링 및 추천 시스템 정확성 테스트. 이벤트 관리 테스트 - 이벤트 생성, 참석 신청, 알림 발송 플로우 검증. 캘린더 연동 및 시간대 처리 정확성 테스트. 평판 시스템 테스트 - 활동별 포인트 적립 로직 검증. 뱃지 획득 조건 및 레벨 업 시스템 정확성 테스트. 보안 테스트 - 메시지 암호화, 개인정보 보호, 스팸 방지 시스템 검증.",
        "status": "pending",
        "dependencies": [
          18,
          23,
          26,
          27
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "파트너 생태계 및 중개 서비스 플랫폼 구축",
        "description": "전문서비스 제공업체(법무/회계/컨설팅)와의 파트너십을 통한 중개 서비스 플랫폼을 구축하여 서비스 매칭, 수수료 계산, 파트너 관리 시스템을 제공합니다.",
        "details": "Phase 1: 파트너 데이터베이스 및 관리 시스템 구축 - PartnerService 클래스를 BaseService를 상속받아 구현하고, 전문서비스 업체 정보(법무법인, 회계법인, 컨설팅사) 관리 시스템 구축. Partner 모델에 업체명, 전문분야, 지역, 평가점수, 서비스 가격, 자격증명 등 포함. PartnerRepository로 파트너 검색, 필터링, 평가 관리 기능 구현. Phase 2: 서비스 매칭 및 추천 알고리즘 구현 - MatchingService 클래스로 사용자 요구사항과 파트너 전문분야를 매칭하는 알고리즘 구현. 지역 근접성(30%), 전문분야 일치도(40%), 평가점수(20%), 가격 적합성(10%) 가중치 적용. 협업 필터링과 콘텐츠 기반 필터링을 결합한 하이브리드 추천 시스템 구축. Phase 3: 중개 수수료 및 정산 시스템 - CommissionService 클래스로 서비스별 수수료 계산 로직 구현 (법무: 15%, 회계: 12%, 컨설팅: 18%). 결제 완료 시 자동 수수료 분배, 월별 정산 스케줄링, 세금계산서 발행 연동. PaymentGateway 연동으로 안전한 결제 처리. Phase 4: 서비스 예약 및 스케줄링 시스템 - BookingService 클래스로 파트너별 가능 시간 관리 및 예약 시스템 구현. 캘린더 API 연동, 실시간 예약 가능 시간 확인, 예약 충돌 방지 로직. 예약 확인/변경/취소 알림 시스템 구축. Phase 5: 파트너 평가 및 피드백 시스템 - ReviewService 클래스로 서비스 완료 후 고객 만족도 조사 및 평가 시스템 구현. 5점 척도 평가, 텍스트 리뷰, 재이용 의향 조사 포함. 평가 결과 기반 파트너 랭킹 및 추천 순위 조정.",
        "testStrategy": "파트너 매칭 알고리즘 테스트 - 다양한 사용자 요구사항에 대한 파트너 추천 정확도 측정, 매칭 점수 계산 로직 검증. 지역/전문분야/평가점수 기반 필터링 결과 정확성 테스트. 수수료 계산 및 정산 시스템 테스트 - 서비스별 수수료율 정확한 적용 검증, 복합 서비스 시 수수료 분배 로직 테스트. 월별 정산 스케줄링 및 자동화 프로세스 검증. 예약 시스템 충돌 방지 테스트 - 동시 예약 요청 시 충돌 방지 로직 검증, 캘린더 API 연동 정확성 테스트. 예약 변경/취소 시나리오 및 알림 발송 테스트. 평가 시스템 신뢰성 테스트 - 허위 평가 감지 및 방지 로직 검증, 평가 결과 기반 랭킹 시스템 정확성 테스트. 성능 테스트 - 1000+ 파트너 데이터에서 매칭 알고리즘 응답시간 < 500ms 검증, 대량 예약 처리 성능 측정.",
        "status": "pending",
        "dependencies": [
          18,
          22,
          23,
          29
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "OAuth 2.0 Google 소셜 로그인 통합",
        "description": "기존 JWT 인증 시스템과 Google OAuth 2.0 소셜 로그인을 완전히 통합하는 하이브리드 인증 시스템을 구현합니다. 프론트엔드 Module Federation과 연동 가능한 인증 API를 제공합니다.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          18
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Google OAuth 2.0 Provider 설정 및 구성",
            "description": "Google Developer Console에서 OAuth 2.0 클라이언트 설정을 구성하고, 환경 변수 및 설정 파일을 통해 Google OAuth Provider를 FastAPI 애플리케이션에 통합합니다.",
            "dependencies": [],
            "details": "Google Developer Console에서 새 프로젝트 생성 및 OAuth 2.0 클라이언트 ID 발급. 승인된 리디렉션 URI 설정 (예: http://localhost:8000/auth/google/callback). 환경 변수에 GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REDIRECT_URI 추가. app/core/config.py에 Google OAuth 설정 클래스 추가. python-jose, passlib 등 필요한 인증 라이브러리 종속성 추가.",
            "status": "done",
            "testStrategy": "환경 변수 로딩 테스트, OAuth 설정 검증 테스트"
          },
          {
            "id": 2,
            "title": "사용자 모델 확장 및 소셜 로그인 지원",
            "description": "기존 사용자 모델을 확장하여 Google OAuth를 통한 소셜 로그인 정보를 저장할 수 있도록 수정하고, provider 정보와 external_id를 관리합니다.",
            "dependencies": [
              "32.1"
            ],
            "details": "User 모델에 provider 필드 (google, local), external_id 필드, profile_image_url 필드 추가. UserCreate, UserUpdate 스키마 확장. Google 프로필 정보 (name, email, picture) 매핑 로직 구현. 기존 로컬 계정과 Google 계정 연결 로직 설계. MongoDB 컬렉션에 적절한 인덱스 추가 (email, provider, external_id).",
            "status": "done",
            "testStrategy": "사용자 모델 검증 테스트, Google 프로필 매핑 테스트, 계정 연결 로직 테스트"
          },
          {
            "id": 3,
            "title": "Google OAuth 인증 플로우 구현",
            "description": "Google OAuth 2.0 인증 플로우를 처리하는 엔드포인트를 구현하여 authorization code 교환, 사용자 정보 조회, JWT 토큰 발급까지의 전체 과정을 관리합니다.",
            "dependencies": [
              "32.1",
              "32.2"
            ],
            "details": "/auth/google/login 엔드포인트: Google OAuth URL 생성 및 리디렉션. /auth/google/callback 엔드포인트: authorization code를 access token으로 교환. Google API를 통한 사용자 프로필 정보 조회 (userinfo endpoint). 신규 사용자 자동 등록 및 기존 사용자 정보 업데이트. JWT access token 및 refresh token 발급. httpx를 활용한 비동기 Google API 호출 구현.",
            "status": "done",
            "testStrategy": "OAuth 플로우 통합 테스트, Google API 호출 Mock 테스트, JWT 토큰 발급 검증"
          },
          {
            "id": 4,
            "title": "하이브리드 인증 미들웨어 구현",
            "description": "기존 JWT 인증과 Google OAuth 토큰을 모두 지원하는 통합 인증 미들웨어를 구현하여 두 가지 인증 방식을 투명하게 처리합니다.",
            "dependencies": [
              "32.2",
              "32.3"
            ],
            "details": "Authorization 헤더에서 Bearer 토큰 추출 및 유형 판별 (JWT vs Google token). JWT 토큰 검증 로직: 기존 verify_token 함수 활용. Google 토큰 검증: Google API tokeninfo endpoint 호출. 인증 성공 시 current_user 컨텍스트 설정. 인증 실패 시 적절한 HTTP 상태 코드 및 에러 메시지 반환. FastAPI Depends를 활용한 의존성 주입 구조 구현.",
            "status": "pending",
            "testStrategy": "JWT 토큰 검증 테스트, Google 토큰 검증 테스트, 미들웨어 통합 테스트"
          },
          {
            "id": 5,
            "title": "사용자 프로필 관리 API 확장",
            "description": "Google OAuth를 통해 로그인한 사용자의 프로필 정보를 관리하고, 계정 연결/해제 기능을 제공하는 API 엔드포인트를 구현합니다.",
            "dependencies": [
              "32.2",
              "32.4"
            ],
            "details": "GET /auth/profile: 현재 사용자 프로필 조회 (provider 정보 포함). POST /auth/link-google: 기존 로컬 계정에 Google 계정 연결. DELETE /auth/unlink-google: Google 계정 연결 해제. PUT /auth/profile: 프로필 정보 업데이트 (Google에서 가져온 정보 우선). 계정 연결/해제 시 보안 검증 (비밀번호 확인 등). UserProfile 응답 스키마에 provider, external_id, profile_image_url 필드 추가.",
            "status": "pending",
            "testStrategy": "프로필 조회 테스트, 계정 연결/해제 테스트, 보안 검증 테스트"
          },
          {
            "id": 6,
            "title": "프론트엔드 연동을 위한 CORS 및 세션 관리",
            "description": "Module Federation 기반 프론트엔드와의 원활한 연동을 위해 CORS 설정을 최적화하고, 세션 관리 및 토큰 갱신 메커니즘을 구현합니다.",
            "dependencies": [
              "32.4",
              "32.5"
            ],
            "details": "CORS 미들웨어 설정: credentials=True, 프론트엔드 도메인 허용. SameSite 쿠키 설정 및 Secure 플래그 적용. Refresh token 자동 갱신 엔드포인트 (/auth/refresh). 로그아웃 시 토큰 무효화 처리. CSRF 보호 메커니즘 구현. 브라우저 세션 스토리지와 연동 가능한 토큰 전달 방식 설계.",
            "status": "pending",
            "testStrategy": "CORS 설정 테스트, 토큰 갱신 플로우 테스트, 세션 관리 테스트"
          },
          {
            "id": 7,
            "title": "OAuth 통합 테스트 및 문서화",
            "description": "전체 OAuth 2.0 Google 로그인 플로우에 대한 종합적인 테스트를 작성하고, API 문서 및 프론트엔드 연동 가이드를 완성합니다.",
            "dependencies": [
              "32.3",
              "32.4",
              "32.5",
              "32.6"
            ],
            "details": "Pytest를 활용한 E2E 테스트 시나리오 작성: 신규 Google 사용자 등록, 기존 사용자 Google 로그인, 계정 연결/해제. Mock Google OAuth API 서버 구축 (httpx-mock 활용). Swagger UI에 OAuth 2.0 Authorization Code Flow 문서 추가. 프론트엔드 개발자를 위한 연동 가이드 작성 (인증 플로우, 토큰 관리, 에러 처리). 보안 체크리스트 및 모범 사례 문서화.",
            "status": "pending",
            "testStrategy": "E2E 인증 플로우 테스트, Mock API 테스트, 문서화 검증 테스트"
          }
        ]
      },
      {
        "id": 33,
        "title": "접근 레벨별 API 권한 미들웨어",
        "description": "익명 사용자, 인증된 사용자, 프리미엄 사용자의 접근 레벨을 구분하는 FastAPI 미들웨어와 권한 데코레이터 시스템을 구현합니다. Rate limiting과 기능별 접근 제어를 포함합니다.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          32
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-21T23:49:16.210Z",
      "updated": "2025-07-27T14:30:48.444Z",
      "description": "Tasks for master context"
    }
  }
}